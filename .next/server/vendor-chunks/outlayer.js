"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/outlayer";
exports.ids = ["vendor-chunks/outlayer"];
exports.modules = {

/***/ "(ssr)/./node_modules/outlayer/item.js":
/*!***************************************!*\
  !*** ./node_modules/outlayer/item.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Outlayer Item\n */ (function(window1, factory) {\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\")\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(EvEmitter, getSize) {\n    \"use strict\";\n    // ----- helpers ----- //\n    function isEmptyObj(obj) {\n        for(var prop in obj){\n            return false;\n        }\n        prop = null;\n        return true;\n    }\n    // -------------------------- CSS3 support -------------------------- //\n    var docElemStyle = document.documentElement.style;\n    var transitionProperty = typeof docElemStyle.transition == \"string\" ? \"transition\" : \"WebkitTransition\";\n    var transformProperty = typeof docElemStyle.transform == \"string\" ? \"transform\" : \"WebkitTransform\";\n    var transitionEndEvent = {\n        WebkitTransition: \"webkitTransitionEnd\",\n        transition: \"transitionend\"\n    }[transitionProperty];\n    // cache all vendor properties that could have vendor prefix\n    var vendorProperties = {\n        transform: transformProperty,\n        transition: transitionProperty,\n        transitionDuration: transitionProperty + \"Duration\",\n        transitionProperty: transitionProperty + \"Property\",\n        transitionDelay: transitionProperty + \"Delay\"\n    };\n    // -------------------------- Item -------------------------- //\n    function Item(element, layout) {\n        if (!element) {\n            return;\n        }\n        this.element = element;\n        // parent layout class, i.e. Masonry, Isotope, or Packery\n        this.layout = layout;\n        this.position = {\n            x: 0,\n            y: 0\n        };\n        this._create();\n    }\n    // inherit EvEmitter\n    var proto = Item.prototype = Object.create(EvEmitter.prototype);\n    proto.constructor = Item;\n    proto._create = function() {\n        // transition objects\n        this._transn = {\n            ingProperties: {},\n            clean: {},\n            onEnd: {}\n        };\n        this.css({\n            position: \"absolute\"\n        });\n    };\n    // trigger specified handler for event type\n    proto.handleEvent = function(event) {\n        var method = \"on\" + event.type;\n        if (this[method]) {\n            this[method](event);\n        }\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * apply CSS styles to element\n * @param {Object} style\n */ proto.css = function(style) {\n        var elemStyle = this.element.style;\n        for(var prop in style){\n            // use vendor property if available\n            var supportedProp = vendorProperties[prop] || prop;\n            elemStyle[supportedProp] = style[prop];\n        }\n    };\n    // measure position, and sets it\n    proto.getPosition = function() {\n        var style = getComputedStyle(this.element);\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        var xValue = style[isOriginLeft ? \"left\" : \"right\"];\n        var yValue = style[isOriginTop ? \"top\" : \"bottom\"];\n        var x = parseFloat(xValue);\n        var y = parseFloat(yValue);\n        // convert percent to pixels\n        var layoutSize = this.layout.size;\n        if (xValue.indexOf(\"%\") != -1) {\n            x = x / 100 * layoutSize.width;\n        }\n        if (yValue.indexOf(\"%\") != -1) {\n            y = y / 100 * layoutSize.height;\n        }\n        // clean up 'auto' or other non-integer values\n        x = isNaN(x) ? 0 : x;\n        y = isNaN(y) ? 0 : y;\n        // remove padding from measurement\n        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n        this.position.x = x;\n        this.position.y = y;\n    };\n    // set settled position, apply padding\n    proto.layoutPosition = function() {\n        var layoutSize = this.layout.size;\n        var style = {};\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        // x\n        var xPadding = isOriginLeft ? \"paddingLeft\" : \"paddingRight\";\n        var xProperty = isOriginLeft ? \"left\" : \"right\";\n        var xResetProperty = isOriginLeft ? \"right\" : \"left\";\n        var x = this.position.x + layoutSize[xPadding];\n        // set in percentage or pixels\n        style[xProperty] = this.getXValue(x);\n        // reset other property\n        style[xResetProperty] = \"\";\n        // y\n        var yPadding = isOriginTop ? \"paddingTop\" : \"paddingBottom\";\n        var yProperty = isOriginTop ? \"top\" : \"bottom\";\n        var yResetProperty = isOriginTop ? \"bottom\" : \"top\";\n        var y = this.position.y + layoutSize[yPadding];\n        // set in percentage or pixels\n        style[yProperty] = this.getYValue(y);\n        // reset other property\n        style[yResetProperty] = \"\";\n        this.css(style);\n        this.emitEvent(\"layout\", [\n            this\n        ]);\n    };\n    proto.getXValue = function(x) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + \"%\" : x + \"px\";\n    };\n    proto.getYValue = function(y) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + \"%\" : y + \"px\";\n    };\n    proto._transitionTo = function(x, y) {\n        this.getPosition();\n        // get current x & y from top/left\n        var curX = this.position.x;\n        var curY = this.position.y;\n        var didNotMove = x == this.position.x && y == this.position.y;\n        // save end position\n        this.setPosition(x, y);\n        // if did not move and not transitioning, just go to layout\n        if (didNotMove && !this.isTransitioning) {\n            this.layoutPosition();\n            return;\n        }\n        var transX = x - curX;\n        var transY = y - curY;\n        var transitionStyle = {};\n        transitionStyle.transform = this.getTranslate(transX, transY);\n        this.transition({\n            to: transitionStyle,\n            onTransitionEnd: {\n                transform: this.layoutPosition\n            },\n            isCleaning: true\n        });\n    };\n    proto.getTranslate = function(x, y) {\n        // flip cooridinates if origin on right or bottom\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        x = isOriginLeft ? x : -x;\n        y = isOriginTop ? y : -y;\n        return \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\n    };\n    // non transition + transform support\n    proto.goTo = function(x, y) {\n        this.setPosition(x, y);\n        this.layoutPosition();\n    };\n    proto.moveTo = proto._transitionTo;\n    proto.setPosition = function(x, y) {\n        this.position.x = parseFloat(x);\n        this.position.y = parseFloat(y);\n    };\n    // ----- transition ----- //\n    /**\n * @param {Object} style - CSS\n * @param {Function} onTransitionEnd\n */ // non transition, just trigger callback\n    proto._nonTransition = function(args) {\n        this.css(args.to);\n        if (args.isCleaning) {\n            this._removeStyles(args.to);\n        }\n        for(var prop in args.onTransitionEnd){\n            args.onTransitionEnd[prop].call(this);\n        }\n    };\n    /**\n * proper transition\n * @param {Object} args - arguments\n *   @param {Object} to - style to transition to\n *   @param {Object} from - style to start transition from\n *   @param {Boolean} isCleaning - removes transition styles after transition\n *   @param {Function} onTransitionEnd - callback\n */ proto.transition = function(args) {\n        // redirect to nonTransition if no transition duration\n        if (!parseFloat(this.layout.options.transitionDuration)) {\n            this._nonTransition(args);\n            return;\n        }\n        var _transition = this._transn;\n        // keep track of onTransitionEnd callback by css property\n        for(var prop in args.onTransitionEnd){\n            _transition.onEnd[prop] = args.onTransitionEnd[prop];\n        }\n        // keep track of properties that are transitioning\n        for(prop in args.to){\n            _transition.ingProperties[prop] = true;\n            // keep track of properties to clean up when transition is done\n            if (args.isCleaning) {\n                _transition.clean[prop] = true;\n            }\n        }\n        // set from styles\n        if (args.from) {\n            this.css(args.from);\n            // force redraw. http://blog.alexmaccaw.com/css-transitions\n            var h = this.element.offsetHeight;\n            // hack for JSHint to hush about unused var\n            h = null;\n        }\n        // enable transition\n        this.enableTransition(args.to);\n        // set styles that are transitioning\n        this.css(args.to);\n        this.isTransitioning = true;\n    };\n    // dash before all cap letters, including first for\n    // WebkitTransform => -webkit-transform\n    function toDashedAll(str) {\n        return str.replace(/([A-Z])/g, function($1) {\n            return \"-\" + $1.toLowerCase();\n        });\n    }\n    var transitionProps = \"opacity,\" + toDashedAll(transformProperty);\n    proto.enableTransition = function() {\n        // HACK changing transitionProperty during a transition\n        // will cause transition to jump\n        if (this.isTransitioning) {\n            return;\n        }\n        // make `transition: foo, bar, baz` from style object\n        // HACK un-comment this when enableTransition can work\n        // while a transition is happening\n        // var transitionValues = [];\n        // for ( var prop in style ) {\n        //   // dash-ify camelCased properties like WebkitTransition\n        //   prop = vendorProperties[ prop ] || prop;\n        //   transitionValues.push( toDashedAll( prop ) );\n        // }\n        // munge number to millisecond, to match stagger\n        var duration = this.layout.options.transitionDuration;\n        duration = typeof duration == \"number\" ? duration + \"ms\" : duration;\n        // enable transition styles\n        this.css({\n            transitionProperty: transitionProps,\n            transitionDuration: duration,\n            transitionDelay: this.staggerDelay || 0\n        });\n        // listen for transition end event\n        this.element.addEventListener(transitionEndEvent, this, false);\n    };\n    // ----- events ----- //\n    proto.onwebkitTransitionEnd = function(event) {\n        this.ontransitionend(event);\n    };\n    proto.onotransitionend = function(event) {\n        this.ontransitionend(event);\n    };\n    // properties that I munge to make my life easier\n    var dashedVendorProperties = {\n        \"-webkit-transform\": \"transform\"\n    };\n    proto.ontransitionend = function(event) {\n        // disregard bubbled events from children\n        if (event.target !== this.element) {\n            return;\n        }\n        var _transition = this._transn;\n        // get property name of transitioned property, convert to prefix-free\n        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;\n        // remove property that has completed transitioning\n        delete _transition.ingProperties[propertyName];\n        // check if any properties are still transitioning\n        if (isEmptyObj(_transition.ingProperties)) {\n            // all properties have completed transitioning\n            this.disableTransition();\n        }\n        // clean style\n        if (propertyName in _transition.clean) {\n            // clean up style\n            this.element.style[event.propertyName] = \"\";\n            delete _transition.clean[propertyName];\n        }\n        // trigger onTransitionEnd callback\n        if (propertyName in _transition.onEnd) {\n            var onTransitionEnd = _transition.onEnd[propertyName];\n            onTransitionEnd.call(this);\n            delete _transition.onEnd[propertyName];\n        }\n        this.emitEvent(\"transitionEnd\", [\n            this\n        ]);\n    };\n    proto.disableTransition = function() {\n        this.removeTransitionStyles();\n        this.element.removeEventListener(transitionEndEvent, this, false);\n        this.isTransitioning = false;\n    };\n    /**\n * removes style property from element\n * @param {Object} style\n**/ proto._removeStyles = function(style) {\n        // clean up transition styles\n        var cleanStyle = {};\n        for(var prop in style){\n            cleanStyle[prop] = \"\";\n        }\n        this.css(cleanStyle);\n    };\n    var cleanTransitionStyle = {\n        transitionProperty: \"\",\n        transitionDuration: \"\",\n        transitionDelay: \"\"\n    };\n    proto.removeTransitionStyles = function() {\n        // remove transition\n        this.css(cleanTransitionStyle);\n    };\n    // ----- stagger ----- //\n    proto.stagger = function(delay) {\n        delay = isNaN(delay) ? 0 : delay;\n        this.staggerDelay = delay + \"ms\";\n    };\n    // ----- show/hide/remove ----- //\n    // remove element from DOM\n    proto.removeElem = function() {\n        this.element.parentNode.removeChild(this.element);\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        this.emitEvent(\"remove\", [\n            this\n        ]);\n    };\n    proto.remove = function() {\n        // just remove element if no transition support or no transition\n        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n            this.removeElem();\n            return;\n        }\n        // start transition\n        this.once(\"transitionEnd\", function() {\n            this.removeElem();\n        });\n        this.hide();\n    };\n    proto.reveal = function() {\n        delete this.isHidden;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"visibleStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;\n        this.transition({\n            from: options.hiddenStyle,\n            to: options.visibleStyle,\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onRevealTransitionEnd = function() {\n        // check if still visible\n        // during transition, item may have been hidden\n        if (!this.isHidden) {\n            this.emitEvent(\"reveal\");\n        }\n    };\n    /**\n * get style property use for hide/reveal transition end\n * @param {String} styleProperty - hiddenStyle/visibleStyle\n * @returns {String}\n */ proto.getHideRevealTransitionEndProperty = function(styleProperty) {\n        var optionStyle = this.layout.options[styleProperty];\n        // use opacity\n        if (optionStyle.opacity) {\n            return \"opacity\";\n        }\n        // get first property\n        for(var prop in optionStyle){\n            return prop;\n        }\n    };\n    proto.hide = function() {\n        // set flag\n        this.isHidden = true;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"hiddenStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;\n        this.transition({\n            from: options.visibleStyle,\n            to: options.hiddenStyle,\n            // keep hidden stuff hidden\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onHideTransitionEnd = function() {\n        // check if still hidden\n        // during transition, item may have been un-hidden\n        if (this.isHidden) {\n            this.css({\n                display: \"none\"\n            });\n            this.emitEvent(\"hide\");\n        }\n    };\n    proto.destroy = function() {\n        this.css({\n            position: \"\",\n            left: \"\",\n            right: \"\",\n            top: \"\",\n            bottom: \"\",\n            transition: \"\",\n            transform: \"\"\n        });\n    };\n    return Item;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RTRDLHNCQUF1QixHQUFHLElBQUksQ0FBQ1EsbUJBQW1CO1FBRW5FLElBQUksQ0FBQzVILFVBQVUsQ0FBQztZQUNkaUYsTUFBTXRCLFFBQVE2RCxZQUFZO1lBQzFCakQsSUFBSVosUUFBUTRELFdBQVc7WUFDdkIsMkJBQTJCO1lBQzNCOUMsWUFBWTtZQUNaRCxpQkFBaUJBO1FBQ25CO0lBQ0Y7SUFFQTFELE1BQU04RyxtQkFBbUIsR0FBRztRQUMxQix3QkFBd0I7UUFDeEIsa0RBQWtEO1FBQ2xELElBQUssSUFBSSxDQUFDVCxRQUFRLEVBQUc7WUFDbkIsSUFBSSxDQUFDNUYsR0FBRyxDQUFDO2dCQUFFdUYsU0FBUztZQUFPO1lBQzNCLElBQUksQ0FBQ3JELFNBQVMsQ0FBQztRQUNqQjtJQUNGO0lBRUEzQyxNQUFNK0csT0FBTyxHQUFHO1FBQ2QsSUFBSSxDQUFDdEcsR0FBRyxDQUFDO1lBQ1BiLFVBQVU7WUFDVm9ILE1BQU07WUFDTkMsT0FBTztZQUNQQyxLQUFLO1lBQ0xDLFFBQVE7WUFDUmpJLFlBQVk7WUFDWkUsV0FBVztRQUNiO0lBQ0Y7SUFFQSxPQUFPYjtBQUVQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcmJlbGx5LW5leHRqcy8uL25vZGVfbW9kdWxlcy9vdXRsYXllci9pdGVtLmpzPzlhNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPdXRsYXllciBJdGVtXG4gKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggW1xuICAgICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJyxcbiAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJ1xuICAgICAgXSxcbiAgICAgIGZhY3RvcnlcbiAgICApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lk91dGxheWVyID0ge307XG4gICAgd2luZG93Lk91dGxheWVyLkl0ZW0gPSBmYWN0b3J5KFxuICAgICAgd2luZG93LkV2RW1pdHRlcixcbiAgICAgIHdpbmRvdy5nZXRTaXplXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIEV2RW1pdHRlciwgZ2V0U2l6ZSApIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0gaGVscGVycyAtLS0tLSAvL1xuXG5mdW5jdGlvbiBpc0VtcHR5T2JqKCBvYmogKSB7XG4gIGZvciAoIHZhciBwcm9wIGluIG9iaiApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvcCA9IG51bGw7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDU1MzIHN1cHBvcnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuXG52YXIgZG9jRWxlbVN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG52YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gdHlwZW9mIGRvY0VsZW1TdHlsZS50cmFuc2l0aW9uID09ICdzdHJpbmcnID9cbiAgJ3RyYW5zaXRpb24nIDogJ1dlYmtpdFRyYW5zaXRpb24nO1xudmFyIHRyYW5zZm9ybVByb3BlcnR5ID0gdHlwZW9mIGRvY0VsZW1TdHlsZS50cmFuc2Zvcm0gPT0gJ3N0cmluZycgP1xuICAndHJhbnNmb3JtJyA6ICdXZWJraXRUcmFuc2Zvcm0nO1xuXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0ge1xuICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xufVsgdHJhbnNpdGlvblByb3BlcnR5IF07XG5cbi8vIGNhY2hlIGFsbCB2ZW5kb3IgcHJvcGVydGllcyB0aGF0IGNvdWxkIGhhdmUgdmVuZG9yIHByZWZpeFxudmFyIHZlbmRvclByb3BlcnRpZXMgPSB7XG4gIHRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcGVydHksXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnRHVyYXRpb24nLFxuICB0cmFuc2l0aW9uUHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdQcm9wZXJ0eScsXG4gIHRyYW5zaXRpb25EZWxheTogdHJhbnNpdGlvblByb3BlcnR5ICsgJ0RlbGF5J1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSXRlbSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBJdGVtKCBlbGVtZW50LCBsYXlvdXQgKSB7XG4gIGlmICggIWVsZW1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgLy8gcGFyZW50IGxheW91dCBjbGFzcywgaS5lLiBNYXNvbnJ5LCBJc290b3BlLCBvciBQYWNrZXJ5XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLnBvc2l0aW9uID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG4vLyBpbmhlcml0IEV2RW1pdHRlclxudmFyIHByb3RvID0gSXRlbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5wcm90by5jb25zdHJ1Y3RvciA9IEl0ZW07XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdHJhbnNpdGlvbiBvYmplY3RzXG4gIHRoaXMuX3RyYW5zbiA9IHtcbiAgICBpbmdQcm9wZXJ0aWVzOiB7fSxcbiAgICBjbGVhbjoge30sXG4gICAgb25FbmQ6IHt9XG4gIH07XG5cbiAgdGhpcy5jc3Moe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gIH0pO1xufTtcblxuLy8gdHJpZ2dlciBzcGVjaWZpZWQgaGFuZGxlciBmb3IgZXZlbnQgdHlwZVxucHJvdG8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8uZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogYXBwbHkgQ1NTIHN0eWxlcyB0byBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqL1xucHJvdG8uY3NzID0gZnVuY3Rpb24oIHN0eWxlICkge1xuICB2YXIgZWxlbVN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlO1xuXG4gIGZvciAoIHZhciBwcm9wIGluIHN0eWxlICkge1xuICAgIC8vIHVzZSB2ZW5kb3IgcHJvcGVydHkgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHN1cHBvcnRlZFByb3AgPSB2ZW5kb3JQcm9wZXJ0aWVzWyBwcm9wIF0gfHwgcHJvcDtcbiAgICBlbGVtU3R5bGVbIHN1cHBvcnRlZFByb3AgXSA9IHN0eWxlWyBwcm9wIF07XG4gIH1cbn07XG5cbiAvLyBtZWFzdXJlIHBvc2l0aW9uLCBhbmQgc2V0cyBpdFxucHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbGVtZW50ICk7XG4gIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5MZWZ0Jyk7XG4gIHZhciBpc09yaWdpblRvcCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuICB2YXIgeFZhbHVlID0gc3R5bGVbIGlzT3JpZ2luTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcgXTtcbiAgdmFyIHlWYWx1ZSA9IHN0eWxlWyBpc09yaWdpblRvcCA/ICd0b3AnIDogJ2JvdHRvbScgXTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KCB4VmFsdWUgKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KCB5VmFsdWUgKTtcbiAgLy8gY29udmVydCBwZXJjZW50IHRvIHBpeGVsc1xuICB2YXIgbGF5b3V0U2l6ZSA9IHRoaXMubGF5b3V0LnNpemU7XG4gIGlmICggeFZhbHVlLmluZGV4T2YoJyUnKSAhPSAtMSApIHtcbiAgICB4ID0gKCB4IC8gMTAwICkgKiBsYXlvdXRTaXplLndpZHRoO1xuICB9XG4gIGlmICggeVZhbHVlLmluZGV4T2YoJyUnKSAhPSAtMSApIHtcbiAgICB5ID0gKCB5IC8gMTAwICkgKiBsYXlvdXRTaXplLmhlaWdodDtcbiAgfVxuICAvLyBjbGVhbiB1cCAnYXV0bycgb3Igb3RoZXIgbm9uLWludGVnZXIgdmFsdWVzXG4gIHggPSBpc05hTiggeCApID8gMCA6IHg7XG4gIHkgPSBpc05hTiggeSApID8gMCA6IHk7XG4gIC8vIHJlbW92ZSBwYWRkaW5nIGZyb20gbWVhc3VyZW1lbnRcbiAgeCAtPSBpc09yaWdpbkxlZnQgPyBsYXlvdXRTaXplLnBhZGRpbmdMZWZ0IDogbGF5b3V0U2l6ZS5wYWRkaW5nUmlnaHQ7XG4gIHkgLT0gaXNPcmlnaW5Ub3AgPyBsYXlvdXRTaXplLnBhZGRpbmdUb3AgOiBsYXlvdXRTaXplLnBhZGRpbmdCb3R0b207XG5cbiAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgdGhpcy5wb3NpdGlvbi55ID0geTtcbn07XG5cbi8vIHNldCBzZXR0bGVkIHBvc2l0aW9uLCBhcHBseSBwYWRkaW5nXG5wcm90by5sYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGF5b3V0U2l6ZSA9IHRoaXMubGF5b3V0LnNpemU7XG4gIHZhciBzdHlsZSA9IHt9O1xuICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcblxuICAvLyB4XG4gIHZhciB4UGFkZGluZyA9IGlzT3JpZ2luTGVmdCA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgdmFyIHhQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHZhciB4UmVzZXRQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cbiAgdmFyIHggPSB0aGlzLnBvc2l0aW9uLnggKyBsYXlvdXRTaXplWyB4UGFkZGluZyBdO1xuICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgc3R5bGVbIHhQcm9wZXJ0eSBdID0gdGhpcy5nZXRYVmFsdWUoIHggKTtcbiAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgc3R5bGVbIHhSZXNldFByb3BlcnR5IF0gPSAnJztcblxuICAvLyB5XG4gIHZhciB5UGFkZGluZyA9IGlzT3JpZ2luVG9wID8gJ3BhZGRpbmdUb3AnIDogJ3BhZGRpbmdCb3R0b20nO1xuICB2YXIgeVByb3BlcnR5ID0gaXNPcmlnaW5Ub3AgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgeVJlc2V0UHJvcGVydHkgPSBpc09yaWdpblRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgdmFyIHkgPSB0aGlzLnBvc2l0aW9uLnkgKyBsYXlvdXRTaXplWyB5UGFkZGluZyBdO1xuICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgc3R5bGVbIHlQcm9wZXJ0eSBdID0gdGhpcy5nZXRZVmFsdWUoIHkgKTtcbiAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgc3R5bGVbIHlSZXNldFByb3BlcnR5IF0gPSAnJztcblxuICB0aGlzLmNzcyggc3R5bGUgKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdsYXlvdXQnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8uZ2V0WFZhbHVlID0gZnVuY3Rpb24oIHggKSB7XG4gIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdob3Jpem9udGFsJyk7XG4gIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiAmJiAhaXNIb3Jpem9udGFsID9cbiAgICAoICggeCAvIHRoaXMubGF5b3V0LnNpemUud2lkdGggKSAqIDEwMCApICsgJyUnIDogeCArICdweCc7XG59O1xuXG5wcm90by5nZXRZVmFsdWUgPSBmdW5jdGlvbiggeSApIHtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ2hvcml6b250YWwnKTtcbiAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMucGVyY2VudFBvc2l0aW9uICYmIGlzSG9yaXpvbnRhbCA/XG4gICAgKCAoIHkgLyB0aGlzLmxheW91dC5zaXplLmhlaWdodCApICogMTAwICkgKyAnJScgOiB5ICsgJ3B4Jztcbn07XG5cbnByb3RvLl90cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5nZXRQb3NpdGlvbigpO1xuICAvLyBnZXQgY3VycmVudCB4ICYgeSBmcm9tIHRvcC9sZWZ0XG4gIHZhciBjdXJYID0gdGhpcy5wb3NpdGlvbi54O1xuICB2YXIgY3VyWSA9IHRoaXMucG9zaXRpb24ueTtcblxuICB2YXIgZGlkTm90TW92ZSA9IHggPT0gdGhpcy5wb3NpdGlvbi54ICYmIHkgPT0gdGhpcy5wb3NpdGlvbi55O1xuXG4gIC8vIHNhdmUgZW5kIHBvc2l0aW9uXG4gIHRoaXMuc2V0UG9zaXRpb24oIHgsIHkgKTtcblxuICAvLyBpZiBkaWQgbm90IG1vdmUgYW5kIG5vdCB0cmFuc2l0aW9uaW5nLCBqdXN0IGdvIHRvIGxheW91dFxuICBpZiAoIGRpZE5vdE1vdmUgJiYgIXRoaXMuaXNUcmFuc2l0aW9uaW5nICkge1xuICAgIHRoaXMubGF5b3V0UG9zaXRpb24oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHJhbnNYID0geCAtIGN1clg7XG4gIHZhciB0cmFuc1kgPSB5IC0gY3VyWTtcbiAgdmFyIHRyYW5zaXRpb25TdHlsZSA9IHt9O1xuICB0cmFuc2l0aW9uU3R5bGUudHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2xhdGUoIHRyYW5zWCwgdHJhbnNZICk7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICB0bzogdHJhbnNpdGlvblN0eWxlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDoge1xuICAgICAgdHJhbnNmb3JtOiB0aGlzLmxheW91dFBvc2l0aW9uXG4gICAgfSxcbiAgICBpc0NsZWFuaW5nOiB0cnVlXG4gIH0pO1xufTtcblxucHJvdG8uZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIC8vIGZsaXAgY29vcmlkaW5hdGVzIGlmIG9yaWdpbiBvbiByaWdodCBvciBib3R0b21cbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gIHggPSBpc09yaWdpbkxlZnQgPyB4IDogLXg7XG4gIHkgPSBpc09yaWdpblRvcCA/IHkgOiAteTtcbiAgcmV0dXJuICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwgJyArIHkgKyAncHgsIDApJztcbn07XG5cbi8vIG5vbiB0cmFuc2l0aW9uICsgdHJhbnNmb3JtIHN1cHBvcnRcbnByb3RvLmdvVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5zZXRQb3NpdGlvbiggeCwgeSApO1xuICB0aGlzLmxheW91dFBvc2l0aW9uKCk7XG59O1xuXG5wcm90by5tb3ZlVG8gPSBwcm90by5fdHJhbnNpdGlvblRvO1xuXG5wcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICB0aGlzLnBvc2l0aW9uLnggPSBwYXJzZUZsb2F0KCB4ICk7XG4gIHRoaXMucG9zaXRpb24ueSA9IHBhcnNlRmxvYXQoIHkgKTtcbn07XG5cbi8vIC0tLS0tIHRyYW5zaXRpb24gLS0tLS0gLy9cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgLSBDU1NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVHJhbnNpdGlvbkVuZFxuICovXG5cbi8vIG5vbiB0cmFuc2l0aW9uLCBqdXN0IHRyaWdnZXIgY2FsbGJhY2tcbnByb3RvLl9ub25UcmFuc2l0aW9uID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG4gIHRoaXMuY3NzKCBhcmdzLnRvICk7XG4gIGlmICggYXJncy5pc0NsZWFuaW5nICkge1xuICAgIHRoaXMuX3JlbW92ZVN0eWxlcyggYXJncy50byApO1xuICB9XG4gIGZvciAoIHZhciBwcm9wIGluIGFyZ3Mub25UcmFuc2l0aW9uRW5kICkge1xuICAgIGFyZ3Mub25UcmFuc2l0aW9uRW5kWyBwcm9wIF0uY2FsbCggdGhpcyApO1xuICB9XG59O1xuXG4vKipcbiAqIHByb3BlciB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIGFyZ3VtZW50c1xuICogICBAcGFyYW0ge09iamVjdH0gdG8gLSBzdHlsZSB0byB0cmFuc2l0aW9uIHRvXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gc3R5bGUgdG8gc3RhcnQgdHJhbnNpdGlvbiBmcm9tXG4gKiAgIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbGVhbmluZyAtIHJlbW92ZXMgdHJhbnNpdGlvbiBzdHlsZXMgYWZ0ZXIgdHJhbnNpdGlvblxuICogICBAcGFyYW0ge0Z1bmN0aW9ufSBvblRyYW5zaXRpb25FbmQgLSBjYWxsYmFja1xuICovXG5wcm90by50cmFuc2l0aW9uID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG4gIC8vIHJlZGlyZWN0IHRvIG5vblRyYW5zaXRpb24gaWYgbm8gdHJhbnNpdGlvbiBkdXJhdGlvblxuICBpZiAoICFwYXJzZUZsb2F0KCB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiApICkge1xuICAgIHRoaXMuX25vblRyYW5zaXRpb24oIGFyZ3MgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3RyYW5zaXRpb24gPSB0aGlzLl90cmFuc247XG4gIC8vIGtlZXAgdHJhY2sgb2Ygb25UcmFuc2l0aW9uRW5kIGNhbGxiYWNrIGJ5IGNzcyBwcm9wZXJ0eVxuICBmb3IgKCB2YXIgcHJvcCBpbiBhcmdzLm9uVHJhbnNpdGlvbkVuZCApIHtcbiAgICBfdHJhbnNpdGlvbi5vbkVuZFsgcHJvcCBdID0gYXJncy5vblRyYW5zaXRpb25FbmRbIHByb3AgXTtcbiAgfVxuICAvLyBrZWVwIHRyYWNrIG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZ1xuICBmb3IgKCBwcm9wIGluIGFyZ3MudG8gKSB7XG4gICAgX3RyYW5zaXRpb24uaW5nUHJvcGVydGllc1sgcHJvcCBdID0gdHJ1ZTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHByb3BlcnRpZXMgdG8gY2xlYW4gdXAgd2hlbiB0cmFuc2l0aW9uIGlzIGRvbmVcbiAgICBpZiAoIGFyZ3MuaXNDbGVhbmluZyApIHtcbiAgICAgIF90cmFuc2l0aW9uLmNsZWFuWyBwcm9wIF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBmcm9tIHN0eWxlc1xuICBpZiAoIGFyZ3MuZnJvbSApIHtcbiAgICB0aGlzLmNzcyggYXJncy5mcm9tICk7XG4gICAgLy8gZm9yY2UgcmVkcmF3LiBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgICB2YXIgaCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgLy8gaGFjayBmb3IgSlNIaW50IHRvIGh1c2ggYWJvdXQgdW51c2VkIHZhclxuICAgIGggPSBudWxsO1xuICB9XG4gIC8vIGVuYWJsZSB0cmFuc2l0aW9uXG4gIHRoaXMuZW5hYmxlVHJhbnNpdGlvbiggYXJncy50byApO1xuICAvLyBzZXQgc3R5bGVzIHRoYXQgYXJlIHRyYW5zaXRpb25pbmdcbiAgdGhpcy5jc3MoIGFyZ3MudG8gKTtcblxuICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbn07XG5cbi8vIGRhc2ggYmVmb3JlIGFsbCBjYXAgbGV0dGVycywgaW5jbHVkaW5nIGZpcnN0IGZvclxuLy8gV2Via2l0VHJhbnNmb3JtID0+IC13ZWJraXQtdHJhbnNmb3JtXG5mdW5jdGlvbiB0b0Rhc2hlZEFsbCggc3RyICkge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoIC8oW0EtWl0pL2csIGZ1bmN0aW9uKCAkMSApIHtcbiAgICByZXR1cm4gJy0nICsgJDEudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSAnb3BhY2l0eSwnICsgdG9EYXNoZWRBbGwoIHRyYW5zZm9ybVByb3BlcnR5ICk7XG5cbnByb3RvLmVuYWJsZVRyYW5zaXRpb24gPSBmdW5jdGlvbigvKiBzdHlsZSAqLykge1xuICAvLyBIQUNLIGNoYW5naW5nIHRyYW5zaXRpb25Qcm9wZXJ0eSBkdXJpbmcgYSB0cmFuc2l0aW9uXG4gIC8vIHdpbGwgY2F1c2UgdHJhbnNpdGlvbiB0byBqdW1wXG4gIGlmICggdGhpcy5pc1RyYW5zaXRpb25pbmcgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbWFrZSBgdHJhbnNpdGlvbjogZm9vLCBiYXIsIGJhemAgZnJvbSBzdHlsZSBvYmplY3RcbiAgLy8gSEFDSyB1bi1jb21tZW50IHRoaXMgd2hlbiBlbmFibGVUcmFuc2l0aW9uIGNhbiB3b3JrXG4gIC8vIHdoaWxlIGEgdHJhbnNpdGlvbiBpcyBoYXBwZW5pbmdcbiAgLy8gdmFyIHRyYW5zaXRpb25WYWx1ZXMgPSBbXTtcbiAgLy8gZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gIC8vICAgLy8gZGFzaC1pZnkgY2FtZWxDYXNlZCBwcm9wZXJ0aWVzIGxpa2UgV2Via2l0VHJhbnNpdGlvblxuICAvLyAgIHByb3AgPSB2ZW5kb3JQcm9wZXJ0aWVzWyBwcm9wIF0gfHwgcHJvcDtcbiAgLy8gICB0cmFuc2l0aW9uVmFsdWVzLnB1c2goIHRvRGFzaGVkQWxsKCBwcm9wICkgKTtcbiAgLy8gfVxuICAvLyBtdW5nZSBudW1iZXIgdG8gbWlsbGlzZWNvbmQsIHRvIG1hdGNoIHN0YWdnZXJcbiAgdmFyIGR1cmF0aW9uID0gdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb247XG4gIGR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09ICdudW1iZXInID8gZHVyYXRpb24gKyAnbXMnIDogZHVyYXRpb247XG4gIC8vIGVuYWJsZSB0cmFuc2l0aW9uIHN0eWxlc1xuICB0aGlzLmNzcyh7XG4gICAgdHJhbnNpdGlvblByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICB0cmFuc2l0aW9uRGVsYXk6IHRoaXMuc3RhZ2dlckRlbGF5IHx8IDBcbiAgfSk7XG4gIC8vIGxpc3RlbiBmb3IgdHJhbnNpdGlvbiBlbmQgZXZlbnRcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcywgZmFsc2UgKTtcbn07XG5cbi8vIC0tLS0tIGV2ZW50cyAtLS0tLSAvL1xuXG5wcm90by5vbndlYmtpdFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMub250cmFuc2l0aW9uZW5kKCBldmVudCApO1xufTtcblxucHJvdG8ub25vdHJhbnNpdGlvbmVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5vbnRyYW5zaXRpb25lbmQoIGV2ZW50ICk7XG59O1xuXG4vLyBwcm9wZXJ0aWVzIHRoYXQgSSBtdW5nZSB0byBtYWtlIG15IGxpZmUgZWFzaWVyXG52YXIgZGFzaGVkVmVuZG9yUHJvcGVydGllcyA9IHtcbiAgJy13ZWJraXQtdHJhbnNmb3JtJzogJ3RyYW5zZm9ybSdcbn07XG5cbnByb3RvLm9udHJhbnNpdGlvbmVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gZGlzcmVnYXJkIGJ1YmJsZWQgZXZlbnRzIGZyb20gY2hpbGRyZW5cbiAgaWYgKCBldmVudC50YXJnZXQgIT09IHRoaXMuZWxlbWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIF90cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNuO1xuICAvLyBnZXQgcHJvcGVydHkgbmFtZSBvZiB0cmFuc2l0aW9uZWQgcHJvcGVydHksIGNvbnZlcnQgdG8gcHJlZml4LWZyZWVcbiAgdmFyIHByb3BlcnR5TmFtZSA9IGRhc2hlZFZlbmRvclByb3BlcnRpZXNbIGV2ZW50LnByb3BlcnR5TmFtZSBdIHx8IGV2ZW50LnByb3BlcnR5TmFtZTtcblxuICAvLyByZW1vdmUgcHJvcGVydHkgdGhhdCBoYXMgY29tcGxldGVkIHRyYW5zaXRpb25pbmdcbiAgZGVsZXRlIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXNbIHByb3BlcnR5TmFtZSBdO1xuICAvLyBjaGVjayBpZiBhbnkgcHJvcGVydGllcyBhcmUgc3RpbGwgdHJhbnNpdGlvbmluZ1xuICBpZiAoIGlzRW1wdHlPYmooIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXMgKSApIHtcbiAgICAvLyBhbGwgcHJvcGVydGllcyBoYXZlIGNvbXBsZXRlZCB0cmFuc2l0aW9uaW5nXG4gICAgdGhpcy5kaXNhYmxlVHJhbnNpdGlvbigpO1xuICB9XG4gIC8vIGNsZWFuIHN0eWxlXG4gIGlmICggcHJvcGVydHlOYW1lIGluIF90cmFuc2l0aW9uLmNsZWFuICkge1xuICAgIC8vIGNsZWFuIHVwIHN0eWxlXG4gICAgdGhpcy5lbGVtZW50LnN0eWxlWyBldmVudC5wcm9wZXJ0eU5hbWUgXSA9ICcnO1xuICAgIGRlbGV0ZSBfdHJhbnNpdGlvbi5jbGVhblsgcHJvcGVydHlOYW1lIF07XG4gIH1cbiAgLy8gdHJpZ2dlciBvblRyYW5zaXRpb25FbmQgY2FsbGJhY2tcbiAgaWYgKCBwcm9wZXJ0eU5hbWUgaW4gX3RyYW5zaXRpb24ub25FbmQgKSB7XG4gICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wZXJ0eU5hbWUgXTtcbiAgICBvblRyYW5zaXRpb25FbmQuY2FsbCggdGhpcyApO1xuICAgIGRlbGV0ZSBfdHJhbnNpdGlvbi5vbkVuZFsgcHJvcGVydHlOYW1lIF07XG4gIH1cblxuICB0aGlzLmVtaXRFdmVudCggJ3RyYW5zaXRpb25FbmQnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8uZGlzYWJsZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVUcmFuc2l0aW9uU3R5bGVzKCk7XG4gIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0cmFuc2l0aW9uRW5kRXZlbnQsIHRoaXMsIGZhbHNlICk7XG4gIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIHJlbW92ZXMgc3R5bGUgcHJvcGVydHkgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbioqL1xucHJvdG8uX3JlbW92ZVN0eWxlcyA9IGZ1bmN0aW9uKCBzdHlsZSApIHtcbiAgLy8gY2xlYW4gdXAgdHJhbnNpdGlvbiBzdHlsZXNcbiAgdmFyIGNsZWFuU3R5bGUgPSB7fTtcbiAgZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgY2xlYW5TdHlsZVsgcHJvcCBdID0gJyc7XG4gIH1cbiAgdGhpcy5jc3MoIGNsZWFuU3R5bGUgKTtcbn07XG5cbnZhciBjbGVhblRyYW5zaXRpb25TdHlsZSA9IHtcbiAgdHJhbnNpdGlvblByb3BlcnR5OiAnJyxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnJyxcbiAgdHJhbnNpdGlvbkRlbGF5OiAnJ1xufTtcblxucHJvdG8ucmVtb3ZlVHJhbnNpdGlvblN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgdHJhbnNpdGlvblxuICB0aGlzLmNzcyggY2xlYW5UcmFuc2l0aW9uU3R5bGUgKTtcbn07XG5cbi8vIC0tLS0tIHN0YWdnZXIgLS0tLS0gLy9cblxucHJvdG8uc3RhZ2dlciA9IGZ1bmN0aW9uKCBkZWxheSApIHtcbiAgZGVsYXkgPSBpc05hTiggZGVsYXkgKSA/IDAgOiBkZWxheTtcbiAgdGhpcy5zdGFnZ2VyRGVsYXkgPSBkZWxheSArICdtcyc7XG59O1xuXG4vLyAtLS0tLSBzaG93L2hpZGUvcmVtb3ZlIC0tLS0tIC8vXG5cbi8vIHJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG5wcm90by5yZW1vdmVFbGVtID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbiAgLy8gcmVtb3ZlIGRpc3BsYXk6IG5vbmVcbiAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcbiAgdGhpcy5lbWl0RXZlbnQoICdyZW1vdmUnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGp1c3QgcmVtb3ZlIGVsZW1lbnQgaWYgbm8gdHJhbnNpdGlvbiBzdXBwb3J0IG9yIG5vIHRyYW5zaXRpb25cbiAgaWYgKCAhdHJhbnNpdGlvblByb3BlcnR5IHx8ICFwYXJzZUZsb2F0KCB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiApICkge1xuICAgIHRoaXMucmVtb3ZlRWxlbSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHN0YXJ0IHRyYW5zaXRpb25cbiAgdGhpcy5vbmNlKCAndHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlRWxlbSgpO1xuICB9KTtcbiAgdGhpcy5oaWRlKCk7XG59O1xuXG5wcm90by5yZXZlYWwgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuaXNIaWRkZW47XG4gIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmxheW91dC5vcHRpb25zO1xuXG4gIHZhciBvblRyYW5zaXRpb25FbmQgPSB7fTtcbiAgdmFyIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSA9IHRoaXMuZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSgndmlzaWJsZVN0eWxlJyk7XG4gIG9uVHJhbnNpdGlvbkVuZFsgdHJhbnNpdGlvbkVuZFByb3BlcnR5IF0gPSB0aGlzLm9uUmV2ZWFsVHJhbnNpdGlvbkVuZDtcblxuICB0aGlzLnRyYW5zaXRpb24oe1xuICAgIGZyb206IG9wdGlvbnMuaGlkZGVuU3R5bGUsXG4gICAgdG86IG9wdGlvbnMudmlzaWJsZVN0eWxlLFxuICAgIGlzQ2xlYW5pbmc6IHRydWUsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblRyYW5zaXRpb25FbmRcbiAgfSk7XG59O1xuXG5wcm90by5vblJldmVhbFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgaWYgc3RpbGwgdmlzaWJsZVxuICAvLyBkdXJpbmcgdHJhbnNpdGlvbiwgaXRlbSBtYXkgaGF2ZSBiZWVuIGhpZGRlblxuICBpZiAoICF0aGlzLmlzSGlkZGVuICkge1xuICAgIHRoaXMuZW1pdEV2ZW50KCdyZXZlYWwnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgc3R5bGUgcHJvcGVydHkgdXNlIGZvciBoaWRlL3JldmVhbCB0cmFuc2l0aW9uIGVuZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlUHJvcGVydHkgLSBoaWRkZW5TdHlsZS92aXNpYmxlU3R5bGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbnByb3RvLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkgPSBmdW5jdGlvbiggc3R5bGVQcm9wZXJ0eSApIHtcbiAgdmFyIG9wdGlvblN0eWxlID0gdGhpcy5sYXlvdXQub3B0aW9uc1sgc3R5bGVQcm9wZXJ0eSBdO1xuICAvLyB1c2Ugb3BhY2l0eVxuICBpZiAoIG9wdGlvblN0eWxlLm9wYWNpdHkgKSB7XG4gICAgcmV0dXJuICdvcGFjaXR5JztcbiAgfVxuICAvLyBnZXQgZmlyc3QgcHJvcGVydHlcbiAgZm9yICggdmFyIHByb3AgaW4gb3B0aW9uU3R5bGUgKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbnByb3RvLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2V0IGZsYWdcbiAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XG4gIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmxheW91dC5vcHRpb25zO1xuXG4gIHZhciBvblRyYW5zaXRpb25FbmQgPSB7fTtcbiAgdmFyIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSA9IHRoaXMuZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSgnaGlkZGVuU3R5bGUnKTtcbiAgb25UcmFuc2l0aW9uRW5kWyB0cmFuc2l0aW9uRW5kUHJvcGVydHkgXSA9IHRoaXMub25IaWRlVHJhbnNpdGlvbkVuZDtcblxuICB0aGlzLnRyYW5zaXRpb24oe1xuICAgIGZyb206IG9wdGlvbnMudmlzaWJsZVN0eWxlLFxuICAgIHRvOiBvcHRpb25zLmhpZGRlblN0eWxlLFxuICAgIC8vIGtlZXAgaGlkZGVuIHN0dWZmIGhpZGRlblxuICAgIGlzQ2xlYW5pbmc6IHRydWUsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblRyYW5zaXRpb25FbmRcbiAgfSk7XG59O1xuXG5wcm90by5vbkhpZGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGlmIHN0aWxsIGhpZGRlblxuICAvLyBkdXJpbmcgdHJhbnNpdGlvbiwgaXRlbSBtYXkgaGF2ZSBiZWVuIHVuLWhpZGRlblxuICBpZiAoIHRoaXMuaXNIaWRkZW4gKSB7XG4gICAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgdGhpcy5lbWl0RXZlbnQoJ2hpZGUnKTtcbiAgfVxufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNzcyh7XG4gICAgcG9zaXRpb246ICcnLFxuICAgIGxlZnQ6ICcnLFxuICAgIHJpZ2h0OiAnJyxcbiAgICB0b3A6ICcnLFxuICAgIGJvdHRvbTogJycsXG4gICAgdHJhbnNpdGlvbjogJycsXG4gICAgdHJhbnNmb3JtOiAnJ1xuICB9KTtcbn07XG5cbnJldHVybiBJdGVtO1xuXG59KSk7XG4iXSwibmFtZXMiOlsid2luZG93IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiT3V0bGF5ZXIiLCJJdGVtIiwiRXZFbWl0dGVyIiwiZ2V0U2l6ZSIsImlzRW1wdHlPYmoiLCJvYmoiLCJwcm9wIiwiZG9jRWxlbVN0eWxlIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb24iLCJ0cmFuc2Zvcm1Qcm9wZXJ0eSIsInRyYW5zZm9ybSIsInRyYW5zaXRpb25FbmRFdmVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJ2ZW5kb3JQcm9wZXJ0aWVzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkRlbGF5IiwiZWxlbWVudCIsImxheW91dCIsInBvc2l0aW9uIiwieCIsInkiLCJfY3JlYXRlIiwicHJvdG8iLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl90cmFuc24iLCJpbmdQcm9wZXJ0aWVzIiwiY2xlYW4iLCJvbkVuZCIsImNzcyIsImhhbmRsZUV2ZW50IiwiZXZlbnQiLCJtZXRob2QiLCJ0eXBlIiwic2l6ZSIsImVsZW1TdHlsZSIsInN1cHBvcnRlZFByb3AiLCJnZXRQb3NpdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJpc09yaWdpbkxlZnQiLCJfZ2V0T3B0aW9uIiwiaXNPcmlnaW5Ub3AiLCJ4VmFsdWUiLCJ5VmFsdWUiLCJwYXJzZUZsb2F0IiwibGF5b3V0U2l6ZSIsImluZGV4T2YiLCJ3aWR0aCIsImhlaWdodCIsImlzTmFOIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImxheW91dFBvc2l0aW9uIiwieFBhZGRpbmciLCJ4UHJvcGVydHkiLCJ4UmVzZXRQcm9wZXJ0eSIsImdldFhWYWx1ZSIsInlQYWRkaW5nIiwieVByb3BlcnR5IiwieVJlc2V0UHJvcGVydHkiLCJnZXRZVmFsdWUiLCJlbWl0RXZlbnQiLCJpc0hvcml6b250YWwiLCJvcHRpb25zIiwicGVyY2VudFBvc2l0aW9uIiwiX3RyYW5zaXRpb25UbyIsImN1clgiLCJjdXJZIiwiZGlkTm90TW92ZSIsInNldFBvc2l0aW9uIiwiaXNUcmFuc2l0aW9uaW5nIiwidHJhbnNYIiwidHJhbnNZIiwidHJhbnNpdGlvblN0eWxlIiwiZ2V0VHJhbnNsYXRlIiwidG8iLCJvblRyYW5zaXRpb25FbmQiLCJpc0NsZWFuaW5nIiwiZ29UbyIsIm1vdmVUbyIsIl9ub25UcmFuc2l0aW9uIiwiYXJncyIsIl9yZW1vdmVTdHlsZXMiLCJjYWxsIiwiX3RyYW5zaXRpb24iLCJmcm9tIiwiaCIsIm9mZnNldEhlaWdodCIsImVuYWJsZVRyYW5zaXRpb24iLCJ0b0Rhc2hlZEFsbCIsInN0ciIsInJlcGxhY2UiLCIkMSIsInRvTG93ZXJDYXNlIiwidHJhbnNpdGlvblByb3BzIiwiZHVyYXRpb24iLCJzdGFnZ2VyRGVsYXkiLCJhZGRFdmVudExpc3RlbmVyIiwib253ZWJraXRUcmFuc2l0aW9uRW5kIiwib250cmFuc2l0aW9uZW5kIiwib25vdHJhbnNpdGlvbmVuZCIsImRhc2hlZFZlbmRvclByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wZXJ0eU5hbWUiLCJkaXNhYmxlVHJhbnNpdGlvbiIsInJlbW92ZVRyYW5zaXRpb25TdHlsZXMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYW5TdHlsZSIsImNsZWFuVHJhbnNpdGlvblN0eWxlIiwic3RhZ2dlciIsImRlbGF5IiwicmVtb3ZlRWxlbSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImRpc3BsYXkiLCJyZW1vdmUiLCJvbmNlIiwiaGlkZSIsInJldmVhbCIsImlzSGlkZGVuIiwidHJhbnNpdGlvbkVuZFByb3BlcnR5IiwiZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSIsIm9uUmV2ZWFsVHJhbnNpdGlvbkVuZCIsImhpZGRlblN0eWxlIiwidmlzaWJsZVN0eWxlIiwic3R5bGVQcm9wZXJ0eSIsIm9wdGlvblN0eWxlIiwib3BhY2l0eSIsIm9uSGlkZVRyYW5zaXRpb25FbmQiLCJkZXN0cm95IiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/outlayer/outlayer.js":
/*!*******************************************!*\
  !*** ./node_modules/outlayer/outlayer.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/*!\n * Outlayer v2.1.1\n * the brains and guts of a layout library\n * MIT license\n */ (function(window1, factory) {\n    \"use strict\";\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\"),\n            __webpack_require__(/*! fizzy-ui-utils/utils */ \"(ssr)/./node_modules/fizzy-ui-utils/utils.js\"),\n            __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/outlayer/item.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(EvEmitter, getSize, utils, Item) {\n            return factory(window1, EvEmitter, getSize, utils, Item);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(window1, EvEmitter, getSize, utils, Item) {\n    \"use strict\";\n    // ----- vars ----- //\n    var console = window1.console;\n    var jQuery = window1.jQuery;\n    var noop = function() {};\n    // -------------------------- Outlayer -------------------------- //\n    // globally unique identifiers\n    var GUID = 0;\n    // internal store of all Outlayer intances\n    var instances = {};\n    /**\n * @param {Element, String} element\n * @param {Object} options\n * @constructor\n */ function Outlayer(element, options) {\n        var queryElement = utils.getQueryElement(element);\n        if (!queryElement) {\n            if (console) {\n                console.error(\"Bad element for \" + this.constructor.namespace + \": \" + (queryElement || element));\n            }\n            return;\n        }\n        this.element = queryElement;\n        // add jQuery\n        if (jQuery) {\n            this.$element = jQuery(this.element);\n        }\n        // options\n        this.options = utils.extend({}, this.constructor.defaults);\n        this.option(options);\n        // add id for Outlayer.getFromElement\n        var id = ++GUID;\n        this.element.outlayerGUID = id; // expando\n        instances[id] = this; // associate via id\n        // kick it off\n        this._create();\n        var isInitLayout = this._getOption(\"initLayout\");\n        if (isInitLayout) {\n            this.layout();\n        }\n    }\n    // settings are for internal use only\n    Outlayer.namespace = \"outlayer\";\n    Outlayer.Item = Item;\n    // default options\n    Outlayer.defaults = {\n        containerStyle: {\n            position: \"relative\"\n        },\n        initLayout: true,\n        originLeft: true,\n        originTop: true,\n        resize: true,\n        resizeContainer: true,\n        // item options\n        transitionDuration: \"0.4s\",\n        hiddenStyle: {\n            opacity: 0,\n            transform: \"scale(0.001)\"\n        },\n        visibleStyle: {\n            opacity: 1,\n            transform: \"scale(1)\"\n        }\n    };\n    var proto = Outlayer.prototype;\n    // inherit EvEmitter\n    utils.extend(proto, EvEmitter.prototype);\n    /**\n * set options\n * @param {Object} opts\n */ proto.option = function(opts) {\n        utils.extend(this.options, opts);\n    };\n    /**\n * get backwards compatible option value, check old name\n */ proto._getOption = function(option) {\n        var oldOption = this.constructor.compatOptions[option];\n        return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];\n    };\n    Outlayer.compatOptions = {\n        // currentName: oldName\n        initLayout: \"isInitLayout\",\n        horizontal: \"isHorizontal\",\n        layoutInstant: \"isLayoutInstant\",\n        originLeft: \"isOriginLeft\",\n        originTop: \"isOriginTop\",\n        resize: \"isResizeBound\",\n        resizeContainer: \"isResizingContainer\"\n    };\n    proto._create = function() {\n        // get items from children\n        this.reloadItems();\n        // elements that affect layout, but are not laid out\n        this.stamps = [];\n        this.stamp(this.options.stamp);\n        // set container style\n        utils.extend(this.element.style, this.options.containerStyle);\n        // bind resize method\n        var canBindResize = this._getOption(\"resize\");\n        if (canBindResize) {\n            this.bindResize();\n        }\n    };\n    // goes through all children again and gets bricks in proper order\n    proto.reloadItems = function() {\n        // collection of item elements\n        this.items = this._itemize(this.element.children);\n    };\n    /**\n * turn elements into Outlayer.Items to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Outlayer Items\n */ proto._itemize = function(elems) {\n        var itemElems = this._filterFindItemElements(elems);\n        var Item = this.constructor.Item;\n        // create new Outlayer Items for collection\n        var items = [];\n        for(var i = 0; i < itemElems.length; i++){\n            var elem = itemElems[i];\n            var item = new Item(elem, this);\n            items.push(item);\n        }\n        return items;\n    };\n    /**\n * get item elements to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - item elements\n */ proto._filterFindItemElements = function(elems) {\n        return utils.filterFindElements(elems, this.options.itemSelector);\n    };\n    /**\n * getter method for getting item elements\n * @returns {Array} elems - collection of item elements\n */ proto.getItemElements = function() {\n        return this.items.map(function(item) {\n            return item.element;\n        });\n    };\n    // ----- init & layout ----- //\n    /**\n * lays out all items\n */ proto.layout = function() {\n        this._resetLayout();\n        this._manageStamps();\n        // don't animate first layout\n        var layoutInstant = this._getOption(\"layoutInstant\");\n        var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;\n        this.layoutItems(this.items, isInstant);\n        // flag for initalized\n        this._isLayoutInited = true;\n    };\n    // _init is alias for layout\n    proto._init = proto.layout;\n    /**\n * logic before any new layout\n */ proto._resetLayout = function() {\n        this.getSize();\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * get measurement from option, for columnWidth, rowHeight, gutter\n * if option is String -> get element from selector string, & get size of element\n * if option is Element -> get size of element\n * else use option as a number\n *\n * @param {String} measurement\n * @param {String} size - width or height\n * @private\n */ proto._getMeasurement = function(measurement, size) {\n        var option = this.options[measurement];\n        var elem;\n        if (!option) {\n            // default to 0\n            this[measurement] = 0;\n        } else {\n            // use option as an element\n            if (typeof option == \"string\") {\n                elem = this.element.querySelector(option);\n            } else if (option instanceof HTMLElement) {\n                elem = option;\n            }\n            // use size of element, if element\n            this[measurement] = elem ? getSize(elem)[size] : option;\n        }\n    };\n    /**\n * layout a collection of item elements\n * @api public\n */ proto.layoutItems = function(items, isInstant) {\n        items = this._getItemsForLayout(items);\n        this._layoutItems(items, isInstant);\n        this._postLayout();\n    };\n    /**\n * get the items to be laid out\n * you may want to skip over some items\n * @param {Array} items\n * @returns {Array} items\n */ proto._getItemsForLayout = function(items) {\n        return items.filter(function(item) {\n            return !item.isIgnored;\n        });\n    };\n    /**\n * layout items\n * @param {Array} items\n * @param {Boolean} isInstant\n */ proto._layoutItems = function(items, isInstant) {\n        this._emitCompleteOnItems(\"layout\", items);\n        if (!items || !items.length) {\n            // no items, emit event with empty array\n            return;\n        }\n        var queue = [];\n        items.forEach(function(item) {\n            // get x/y object from method\n            var position = this._getItemLayoutPosition(item);\n            // enqueue\n            position.item = item;\n            position.isInstant = isInstant || item.isLayoutInstant;\n            queue.push(position);\n        }, this);\n        this._processLayoutQueue(queue);\n    };\n    /**\n * get item layout position\n * @param {Outlayer.Item} item\n * @returns {Object} x and y position\n */ proto._getItemLayoutPosition = function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    };\n    /**\n * iterate over array and position each item\n * Reason being - separating this logic prevents 'layout invalidation'\n * thx @paul_irish\n * @param {Array} queue\n */ proto._processLayoutQueue = function(queue) {\n        this.updateStagger();\n        queue.forEach(function(obj, i) {\n            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);\n        }, this);\n    };\n    // set stagger from option in milliseconds number\n    proto.updateStagger = function() {\n        var stagger = this.options.stagger;\n        if (stagger === null || stagger === undefined) {\n            this.stagger = 0;\n            return;\n        }\n        this.stagger = getMilliseconds(stagger);\n        return this.stagger;\n    };\n    /**\n * Sets position of item in DOM\n * @param {Outlayer.Item} item\n * @param {Number} x - horizontal position\n * @param {Number} y - vertical position\n * @param {Boolean} isInstant - disables transitions\n */ proto._positionItem = function(item, x, y, isInstant, i) {\n        if (isInstant) {\n            // if not transition, just set CSS\n            item.goTo(x, y);\n        } else {\n            item.stagger(i * this.stagger);\n            item.moveTo(x, y);\n        }\n    };\n    /**\n * Any logic you want to do after each layout,\n * i.e. size the container\n */ proto._postLayout = function() {\n        this.resizeContainer();\n    };\n    proto.resizeContainer = function() {\n        var isResizingContainer = this._getOption(\"resizeContainer\");\n        if (!isResizingContainer) {\n            return;\n        }\n        var size = this._getContainerSize();\n        if (size) {\n            this._setContainerMeasure(size.width, true);\n            this._setContainerMeasure(size.height, false);\n        }\n    };\n    /**\n * Sets width or height of container if returned\n * @returns {Object} size\n *   @param {Number} width\n *   @param {Number} height\n */ proto._getContainerSize = noop;\n    /**\n * @param {Number} measure - size of width or height\n * @param {Boolean} isWidth\n */ proto._setContainerMeasure = function(measure, isWidth) {\n        if (measure === undefined) {\n            return;\n        }\n        var elemSize = this.size;\n        // add padding and border width if border box\n        if (elemSize.isBorderBox) {\n            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;\n        }\n        measure = Math.max(measure, 0);\n        this.element.style[isWidth ? \"width\" : \"height\"] = measure + \"px\";\n    };\n    /**\n * emit eventComplete on a collection of items events\n * @param {String} eventName\n * @param {Array} items - Outlayer.Items\n */ proto._emitCompleteOnItems = function(eventName, items) {\n        var _this = this;\n        function onComplete() {\n            _this.dispatchEvent(eventName + \"Complete\", null, [\n                items\n            ]);\n        }\n        var count = items.length;\n        if (!items || !count) {\n            onComplete();\n            return;\n        }\n        var doneCount = 0;\n        function tick() {\n            doneCount++;\n            if (doneCount == count) {\n                onComplete();\n            }\n        }\n        // bind callback\n        items.forEach(function(item) {\n            item.once(eventName, tick);\n        });\n    };\n    /**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */ proto.dispatchEvent = function(type, event, args) {\n        // add original event to arguments\n        var emitArgs = event ? [\n            event\n        ].concat(args) : args;\n        this.emitEvent(type, emitArgs);\n        if (jQuery) {\n            // set this.$element\n            this.$element = this.$element || jQuery(this.element);\n            if (event) {\n                // create jQuery event\n                var $event = jQuery.Event(event);\n                $event.type = type;\n                this.$element.trigger($event, args);\n            } else {\n                // just trigger with type if no event available\n                this.$element.trigger(type, args);\n            }\n        }\n    };\n    // -------------------------- ignore & stamps -------------------------- //\n    /**\n * keep item in collection, but do not lay it out\n * ignored items do not get skipped in layout\n * @param {Element} elem\n */ proto.ignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            item.isIgnored = true;\n        }\n    };\n    /**\n * return item to layout collection\n * @param {Element} elem\n */ proto.unignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            delete item.isIgnored;\n        }\n    };\n    /**\n * adds elements to stamps\n * @param {NodeList, Array, Element, or String} elems\n */ proto.stamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        this.stamps = this.stamps.concat(elems);\n        // ignore\n        elems.forEach(this.ignore, this);\n    };\n    /**\n * removes elements to stamps\n * @param {NodeList, Array, or Element} elems\n */ proto.unstamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        elems.forEach(function(elem) {\n            // filter out removed stamp elements\n            utils.removeFrom(this.stamps, elem);\n            this.unignore(elem);\n        }, this);\n    };\n    /**\n * finds child elements\n * @param {NodeList, Array, Element, or String} elems\n * @returns {Array} elems\n */ proto._find = function(elems) {\n        if (!elems) {\n            return;\n        }\n        // if string, use argument as selector string\n        if (typeof elems == \"string\") {\n            elems = this.element.querySelectorAll(elems);\n        }\n        elems = utils.makeArray(elems);\n        return elems;\n    };\n    proto._manageStamps = function() {\n        if (!this.stamps || !this.stamps.length) {\n            return;\n        }\n        this._getBoundingRect();\n        this.stamps.forEach(this._manageStamp, this);\n    };\n    // update boundingLeft / Top\n    proto._getBoundingRect = function() {\n        // get bounding rect for container element\n        var boundingRect = this.element.getBoundingClientRect();\n        var size = this.size;\n        this._boundingRect = {\n            left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n            top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n            right: boundingRect.right - (size.paddingRight + size.borderRightWidth),\n            bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n        };\n    };\n    /**\n * @param {Element} stamp\n**/ proto._manageStamp = noop;\n    /**\n * get x/y position of element relative to container element\n * @param {Element} elem\n * @returns {Object} offset - has left, top, right, bottom\n */ proto._getElementOffset = function(elem) {\n        var boundingRect = elem.getBoundingClientRect();\n        var thisRect = this._boundingRect;\n        var size = getSize(elem);\n        var offset = {\n            left: boundingRect.left - thisRect.left - size.marginLeft,\n            top: boundingRect.top - thisRect.top - size.marginTop,\n            right: thisRect.right - boundingRect.right - size.marginRight,\n            bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n        };\n        return offset;\n    };\n    // -------------------------- resize -------------------------- //\n    // enable event handlers for listeners\n    // i.e. resize -> onresize\n    proto.handleEvent = utils.handleEvent;\n    /**\n * Bind layout to window resizing\n */ proto.bindResize = function() {\n        window1.addEventListener(\"resize\", this);\n        this.isResizeBound = true;\n    };\n    /**\n * Unbind layout to window resizing\n */ proto.unbindResize = function() {\n        window1.removeEventListener(\"resize\", this);\n        this.isResizeBound = false;\n    };\n    proto.onresize = function() {\n        this.resize();\n    };\n    utils.debounceMethod(Outlayer, \"onresize\", 100);\n    proto.resize = function() {\n        // don't trigger if size did not change\n        // or if resize was unbound. See #9\n        if (!this.isResizeBound || !this.needsResizeLayout()) {\n            return;\n        }\n        this.layout();\n    };\n    /**\n * check if layout is needed post layout\n * @returns Boolean\n */ proto.needsResizeLayout = function() {\n        var size = getSize(this.element);\n        // check that this.size and size are there\n        // IE8 triggers resize on body size change, so they might not be\n        var hasSizes = this.size && size;\n        return hasSizes && size.innerWidth !== this.size.innerWidth;\n    };\n    // -------------------------- methods -------------------------- //\n    /**\n * add items to Outlayer instance\n * @param {Array or NodeList or Element} elems\n * @returns {Array} items - Outlayer.Items\n**/ proto.addItems = function(elems) {\n        var items = this._itemize(elems);\n        // add items to collection\n        if (items.length) {\n            this.items = this.items.concat(items);\n        }\n        return items;\n    };\n    /**\n * Layout newly-appended item elements\n * @param {Array or NodeList or Element} elems\n */ proto.appended = function(elems) {\n        var items = this.addItems(elems);\n        if (!items.length) {\n            return;\n        }\n        // layout and reveal just the new items\n        this.layoutItems(items, true);\n        this.reveal(items);\n    };\n    /**\n * Layout prepended elements\n * @param {Array or NodeList or Element} elems\n */ proto.prepended = function(elems) {\n        var items = this._itemize(elems);\n        if (!items.length) {\n            return;\n        }\n        // add items to beginning of collection\n        var previousItems = this.items.slice(0);\n        this.items = items.concat(previousItems);\n        // start new layout\n        this._resetLayout();\n        this._manageStamps();\n        // layout new stuff without transition\n        this.layoutItems(items, true);\n        this.reveal(items);\n        // layout previous items\n        this.layoutItems(previousItems);\n    };\n    /**\n * reveal a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.reveal = function(items) {\n        this._emitCompleteOnItems(\"reveal\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.reveal();\n        });\n    };\n    /**\n * hide a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.hide = function(items) {\n        this._emitCompleteOnItems(\"hide\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.hide();\n        });\n    };\n    /**\n * reveal item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.revealItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.reveal(items);\n    };\n    /**\n * hide item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.hideItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.hide(items);\n    };\n    /**\n * get Outlayer.Item, given an Element\n * @param {Element} elem\n * @param {Function} callback\n * @returns {Outlayer.Item} item\n */ proto.getItem = function(elem) {\n        // loop through items to get the one that matches\n        for(var i = 0; i < this.items.length; i++){\n            var item = this.items[i];\n            if (item.element == elem) {\n                // return item\n                return item;\n            }\n        }\n    };\n    /**\n * get collection of Outlayer.Items, given Elements\n * @param {Array} elems\n * @returns {Array} items - Outlayer.Items\n */ proto.getItems = function(elems) {\n        elems = utils.makeArray(elems);\n        var items = [];\n        elems.forEach(function(elem) {\n            var item = this.getItem(elem);\n            if (item) {\n                items.push(item);\n            }\n        }, this);\n        return items;\n    };\n    /**\n * remove element(s) from instance and DOM\n * @param {Array or NodeList or Element} elems\n */ proto.remove = function(elems) {\n        var removeItems = this.getItems(elems);\n        this._emitCompleteOnItems(\"remove\", removeItems);\n        // bail if no items to remove\n        if (!removeItems || !removeItems.length) {\n            return;\n        }\n        removeItems.forEach(function(item) {\n            item.remove();\n            // remove item from collection\n            utils.removeFrom(this.items, item);\n        }, this);\n    };\n    // ----- destroy ----- //\n    // remove and disable Outlayer instance\n    proto.destroy = function() {\n        // clean up dynamic styles\n        var style = this.element.style;\n        style.height = \"\";\n        style.position = \"\";\n        style.width = \"\";\n        // destroy items\n        this.items.forEach(function(item) {\n            item.destroy();\n        });\n        this.unbindResize();\n        var id = this.element.outlayerGUID;\n        delete instances[id]; // remove reference to instance by id\n        delete this.element.outlayerGUID;\n        // remove data for jQuery\n        if (jQuery) {\n            jQuery.removeData(this.element, this.constructor.namespace);\n        }\n    };\n    // -------------------------- data -------------------------- //\n    /**\n * get Outlayer instance from element\n * @param {Element} elem\n * @returns {Outlayer}\n */ Outlayer.data = function(elem) {\n        elem = utils.getQueryElement(elem);\n        var id = elem && elem.outlayerGUID;\n        return id && instances[id];\n    };\n    // -------------------------- create Outlayer class -------------------------- //\n    /**\n * create a layout class\n * @param {String} namespace\n */ Outlayer.create = function(namespace, options) {\n        // sub-class Outlayer\n        var Layout = subclass(Outlayer);\n        // apply new options and compatOptions\n        Layout.defaults = utils.extend({}, Outlayer.defaults);\n        utils.extend(Layout.defaults, options);\n        Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);\n        Layout.namespace = namespace;\n        Layout.data = Outlayer.data;\n        // sub-class Item\n        Layout.Item = subclass(Item);\n        // -------------------------- declarative -------------------------- //\n        utils.htmlInit(Layout, namespace);\n        // -------------------------- jQuery bridge -------------------------- //\n        // make into jQuery plugin\n        if (jQuery && jQuery.bridget) {\n            jQuery.bridget(namespace, Layout);\n        }\n        return Layout;\n    };\n    function subclass(Parent) {\n        function SubClass() {\n            Parent.apply(this, arguments);\n        }\n        SubClass.prototype = Object.create(Parent.prototype);\n        SubClass.prototype.constructor = SubClass;\n        return SubClass;\n    }\n    // ----- helpers ----- //\n    // how many milliseconds are in each unit\n    var msUnits = {\n        ms: 1,\n        s: 1000\n    };\n    // munge time-like parameter into millisecond number\n    // '0.4s' -> 40\n    function getMilliseconds(time) {\n        if (typeof time == \"number\") {\n            return time;\n        }\n        var matches = time.match(/(^\\d*\\.?\\d*)(\\w*)/);\n        var num = matches && matches[1];\n        var unit = matches && matches[2];\n        if (!num.length) {\n            return 0;\n        }\n        num = parseFloat(num);\n        var mult = msUnits[unit] || 1;\n        return num * mult;\n    }\n    // ----- fin ----- //\n    // back in global\n    Outlayer.Item = Item;\n    return Outlayer;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvb3V0bGF5ZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7O0NBSUMsR0FFQyxVQUFVQSxPQUFNLEVBQUVDLE9BQU87SUFDekI7SUFDQSw4QkFBOEI7SUFDOUIsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQzlELElBQUssSUFBeUMsRUFBRztRQUMvQyxrQkFBa0I7UUFDbEJDLGlDQUFRO1lBQ0o7WUFDQTtZQUNBO1lBQ0E7U0FDRCxtQ0FDRCxTQUFVRSxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxJQUFJO1lBQ3ZDLE9BQU9OLFFBQVNELFNBQVFJLFdBQVdDLFNBQVNDLE9BQU9DO1FBQ3JELENBQUM7QUFBQTtJQUVMLE9BQU8sRUFrQk47QUFFSCxHQUFHUCxRQUFRLFNBQVNDLFFBQVNELE9BQU0sRUFBRUksU0FBUyxFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUNwRTtJQUVBLHNCQUFzQjtJQUV0QixJQUFJTSxVQUFVYixRQUFPYSxPQUFPO0lBQzVCLElBQUlDLFNBQVNkLFFBQU9jLE1BQU07SUFDMUIsSUFBSUMsT0FBTyxZQUFZO0lBRXZCLG9FQUFvRTtJQUVwRSw4QkFBOEI7SUFDOUIsSUFBSUMsT0FBTztJQUNYLDBDQUEwQztJQUMxQyxJQUFJQyxZQUFZLENBQUM7SUFHakI7Ozs7Q0FJQyxHQUNELFNBQVNOLFNBQVVPLE9BQU8sRUFBRUMsT0FBTztRQUNqQyxJQUFJQyxlQUFlZCxNQUFNZSxlQUFlLENBQUVIO1FBQzFDLElBQUssQ0FBQ0UsY0FBZTtZQUNuQixJQUFLUCxTQUFVO2dCQUNiQSxRQUFRUyxLQUFLLENBQUUscUJBQXFCLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxTQUFTLEdBQzVELE9BQVNKLENBQUFBLGdCQUFnQkYsT0FBTTtZQUNuQztZQUNBO1FBQ0Y7UUFDQSxJQUFJLENBQUNBLE9BQU8sR0FBR0U7UUFDZixhQUFhO1FBQ2IsSUFBS04sUUFBUztZQUNaLElBQUksQ0FB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T0EsUUFBUSxVQUFXO1lBQzdCLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJQyxVQUFVRCxLQUFLRSxLQUFLLENBQUU7UUFDMUIsSUFBSUMsTUFBTUYsV0FBV0EsT0FBTyxDQUFDLEVBQUU7UUFDL0IsSUFBSUcsT0FBT0gsV0FBV0EsT0FBTyxDQUFDLEVBQUU7UUFDaEMsSUFBSyxDQUFDRSxJQUFJNUksTUFBTSxFQUFHO1lBQ2pCLE9BQU87UUFDVDtRQUNBNEksTUFBTUUsV0FBWUY7UUFDbEIsSUFBSUcsT0FBT1QsT0FBTyxDQUFFTyxLQUFNLElBQUk7UUFDOUIsT0FBT0QsTUFBTUc7SUFDZjtJQUVBLHFCQUFxQjtJQUVyQixpQkFBaUI7SUFDakJ4TSxTQUFTSixJQUFJLEdBQUdBO0lBRWhCLE9BQU9JO0FBRVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFyYmVsbHktbmV4dGpzLy4vbm9kZV9tb2R1bGVzL291dGxheWVyL291dGxheWVyLmpzPzMyMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBPdXRsYXllciB2Mi4xLjFcbiAqIHRoZSBicmFpbnMgYW5kIGd1dHMgb2YgYSBsYXlvdXQgbGlicmFyeVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICBkZWZpbmUoIFtcbiAgICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsXG4gICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZScsXG4gICAgICAgICdmaXp6eS11aS11dGlscy91dGlscycsXG4gICAgICAgICcuL2l0ZW0nXG4gICAgICBdLFxuICAgICAgZnVuY3Rpb24oIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0gKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0pO1xuICAgICAgfVxuICAgICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpLFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJyksXG4gICAgICByZXF1aXJlKCcuL2l0ZW0nKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuT3V0bGF5ZXIgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LkV2RW1pdHRlcixcbiAgICAgIHdpbmRvdy5nZXRTaXplLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlscyxcbiAgICAgIHdpbmRvdy5PdXRsYXllci5JdGVtXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSApIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0gdmFycyAtLS0tLSAvL1xuXG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE91dGxheWVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyc1xudmFyIEdVSUQgPSAwO1xuLy8gaW50ZXJuYWwgc3RvcmUgb2YgYWxsIE91dGxheWVyIGludGFuY2VzXG52YXIgaW5zdGFuY2VzID0ge307XG5cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQsIFN0cmluZ30gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPdXRsYXllciggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgdmFyIHF1ZXJ5RWxlbWVudCA9IHV0aWxzLmdldFF1ZXJ5RWxlbWVudCggZWxlbWVudCApO1xuICBpZiAoICFxdWVyeUVsZW1lbnQgKSB7XG4gICAgaWYgKCBjb25zb2xlICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ0JhZCBlbGVtZW50IGZvciAnICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lc3BhY2UgK1xuICAgICAgICAnOiAnICsgKCBxdWVyeUVsZW1lbnQgfHwgZWxlbWVudCApICk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmVsZW1lbnQgPSBxdWVyeUVsZW1lbnQ7XG4gIC8vIGFkZCBqUXVlcnlcbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gIH1cblxuICAvLyBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCgge30sIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHMgKTtcbiAgdGhpcy5vcHRpb24oIG9wdGlvbnMgKTtcblxuICAvLyBhZGQgaWQgZm9yIE91dGxheWVyLmdldEZyb21FbGVtZW50XG4gIHZhciBpZCA9ICsrR1VJRDtcbiAgdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRCA9IGlkOyAvLyBleHBhbmRvXG4gIGluc3RhbmNlc1sgaWQgXSA9IHRoaXM7IC8vIGFzc29jaWF0ZSB2aWEgaWRcblxuICAvLyBraWNrIGl0IG9mZlxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB2YXIgaXNJbml0TGF5b3V0ID0gdGhpcy5fZ2V0T3B0aW9uKCdpbml0TGF5b3V0Jyk7XG4gIGlmICggaXNJbml0TGF5b3V0ICkge1xuICAgIHRoaXMubGF5b3V0KCk7XG4gIH1cbn1cblxuLy8gc2V0dGluZ3MgYXJlIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuT3V0bGF5ZXIubmFtZXNwYWNlID0gJ291dGxheWVyJztcbk91dGxheWVyLkl0ZW0gPSBJdGVtO1xuXG4vLyBkZWZhdWx0IG9wdGlvbnNcbk91dGxheWVyLmRlZmF1bHRzID0ge1xuICBjb250YWluZXJTdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gIH0sXG4gIGluaXRMYXlvdXQ6IHRydWUsXG4gIG9yaWdpbkxlZnQ6IHRydWUsXG4gIG9yaWdpblRvcDogdHJ1ZSxcbiAgcmVzaXplOiB0cnVlLFxuICByZXNpemVDb250YWluZXI6IHRydWUsXG4gIC8vIGl0ZW0gb3B0aW9uc1xuICB0cmFuc2l0aW9uRHVyYXRpb246ICcwLjRzJyxcbiAgaGlkZGVuU3R5bGU6IHtcbiAgICBvcGFjaXR5OiAwLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDAuMDAxKSdcbiAgfSxcbiAgdmlzaWJsZVN0eWxlOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgfVxufTtcblxudmFyIHByb3RvID0gT3V0bGF5ZXIucHJvdG90eXBlO1xuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnV0aWxzLmV4dGVuZCggcHJvdG8sIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBzZXQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xucHJvdG8ub3B0aW9uID0gZnVuY3Rpb24oIG9wdHMgKSB7XG4gIHV0aWxzLmV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRzICk7XG59O1xuXG4vKipcbiAqIGdldCBiYWNrd2FyZHMgY29tcGF0aWJsZSBvcHRpb24gdmFsdWUsIGNoZWNrIG9sZCBuYW1lXG4gKi9cbnByb3RvLl9nZXRPcHRpb24gPSBmdW5jdGlvbiggb3B0aW9uICkge1xuICB2YXIgb2xkT3B0aW9uID0gdGhpcy5jb25zdHJ1Y3Rvci5jb21wYXRPcHRpb25zWyBvcHRpb24gXTtcbiAgcmV0dXJuIG9sZE9wdGlvbiAmJiB0aGlzLm9wdGlvbnNbIG9sZE9wdGlvbiBdICE9PSB1bmRlZmluZWQgP1xuICAgIHRoaXMub3B0aW9uc1sgb2xkT3B0aW9uIF0gOiB0aGlzLm9wdGlvbnNbIG9wdGlvbiBdO1xufTtcblxuT3V0bGF5ZXIuY29tcGF0T3B0aW9ucyA9IHtcbiAgLy8gY3VycmVudE5hbWU6IG9sZE5hbWVcbiAgaW5pdExheW91dDogJ2lzSW5pdExheW91dCcsXG4gIGhvcml6b250YWw6ICdpc0hvcml6b250YWwnLFxuICBsYXlvdXRJbnN0YW50OiAnaXNMYXlvdXRJbnN0YW50JyxcbiAgb3JpZ2luTGVmdDogJ2lzT3JpZ2luTGVmdCcsXG4gIG9yaWdpblRvcDogJ2lzT3JpZ2luVG9wJyxcbiAgcmVzaXplOiAnaXNSZXNpemVCb3VuZCcsXG4gIHJlc2l6ZUNvbnRhaW5lcjogJ2lzUmVzaXppbmdDb250YWluZXInXG59O1xuXG5wcm90by5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGdldCBpdGVtcyBmcm9tIGNoaWxkcmVuXG4gIHRoaXMucmVsb2FkSXRlbXMoKTtcbiAgLy8gZWxlbWVudHMgdGhhdCBhZmZlY3QgbGF5b3V0LCBidXQgYXJlIG5vdCBsYWlkIG91dFxuICB0aGlzLnN0YW1wcyA9IFtdO1xuICB0aGlzLnN0YW1wKCB0aGlzLm9wdGlvbnMuc3RhbXAgKTtcbiAgLy8gc2V0IGNvbnRhaW5lciBzdHlsZVxuICB1dGlscy5leHRlbmQoIHRoaXMuZWxlbWVudC5zdHlsZSwgdGhpcy5vcHRpb25zLmNvbnRhaW5lclN0eWxlICk7XG5cbiAgLy8gYmluZCByZXNpemUgbWV0aG9kXG4gIHZhciBjYW5CaW5kUmVzaXplID0gdGhpcy5fZ2V0T3B0aW9uKCdyZXNpemUnKTtcbiAgaWYgKCBjYW5CaW5kUmVzaXplICkge1xuICAgIHRoaXMuYmluZFJlc2l6ZSgpO1xuICB9XG59O1xuXG4vLyBnb2VzIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFnYWluIGFuZCBnZXRzIGJyaWNrcyBpbiBwcm9wZXIgb3JkZXJcbnByb3RvLnJlbG9hZEl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICB0aGlzLml0ZW1zID0gdGhpcy5faXRlbWl6ZSggdGhpcy5lbGVtZW50LmNoaWxkcmVuICk7XG59O1xuXG5cbi8qKlxuICogdHVybiBlbGVtZW50cyBpbnRvIE91dGxheWVyLkl0ZW1zIHRvIGJlIHVzZWQgaW4gbGF5b3V0XG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIGNvbGxlY3Rpb24gb2YgbmV3IE91dGxheWVyIEl0ZW1zXG4gKi9cbnByb3RvLl9pdGVtaXplID0gZnVuY3Rpb24oIGVsZW1zICkge1xuXG4gIHZhciBpdGVtRWxlbXMgPSB0aGlzLl9maWx0ZXJGaW5kSXRlbUVsZW1lbnRzKCBlbGVtcyApO1xuICB2YXIgSXRlbSA9IHRoaXMuY29uc3RydWN0b3IuSXRlbTtcblxuICAvLyBjcmVhdGUgbmV3IE91dGxheWVyIEl0ZW1zIGZvciBjb2xsZWN0aW9uXG4gIHZhciBpdGVtcyA9IFtdO1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgaXRlbUVsZW1zLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBlbGVtID0gaXRlbUVsZW1zW2ldO1xuICAgIHZhciBpdGVtID0gbmV3IEl0ZW0oIGVsZW0sIHRoaXMgKTtcbiAgICBpdGVtcy5wdXNoKCBpdGVtICk7XG4gIH1cblxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIGdldCBpdGVtIGVsZW1lbnRzIHRvIGJlIHVzZWQgaW4gbGF5b3V0XG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIGl0ZW0gZWxlbWVudHNcbiAqL1xucHJvdG8uX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHJldHVybiB1dGlscy5maWx0ZXJGaW5kRWxlbWVudHMoIGVsZW1zLCB0aGlzLm9wdGlvbnMuaXRlbVNlbGVjdG9yICk7XG59O1xuXG4vKipcbiAqIGdldHRlciBtZXRob2QgZm9yIGdldHRpbmcgaXRlbSBlbGVtZW50c1xuICogQHJldHVybnMge0FycmF5fSBlbGVtcyAtIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICovXG5wcm90by5nZXRJdGVtRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICByZXR1cm4gaXRlbS5lbGVtZW50O1xuICB9KTtcbn07XG5cbi8vIC0tLS0tIGluaXQgJiBsYXlvdXQgLS0tLS0gLy9cblxuLyoqXG4gKiBsYXlzIG91dCBhbGwgaXRlbXNcbiAqL1xucHJvdG8ubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0TGF5b3V0KCk7XG4gIHRoaXMuX21hbmFnZVN0YW1wcygpO1xuXG4gIC8vIGRvbid0IGFuaW1hdGUgZmlyc3QgbGF5b3V0XG4gIHZhciBsYXlvdXRJbnN0YW50ID0gdGhpcy5fZ2V0T3B0aW9uKCdsYXlvdXRJbnN0YW50Jyk7XG4gIHZhciBpc0luc3RhbnQgPSBsYXlvdXRJbnN0YW50ICE9PSB1bmRlZmluZWQgP1xuICAgIGxheW91dEluc3RhbnQgOiAhdGhpcy5faXNMYXlvdXRJbml0ZWQ7XG4gIHRoaXMubGF5b3V0SXRlbXMoIHRoaXMuaXRlbXMsIGlzSW5zdGFudCApO1xuXG4gIC8vIGZsYWcgZm9yIGluaXRhbGl6ZWRcbiAgdGhpcy5faXNMYXlvdXRJbml0ZWQgPSB0cnVlO1xufTtcblxuLy8gX2luaXQgaXMgYWxpYXMgZm9yIGxheW91dFxucHJvdG8uX2luaXQgPSBwcm90by5sYXlvdXQ7XG5cbi8qKlxuICogbG9naWMgYmVmb3JlIGFueSBuZXcgbGF5b3V0XG4gKi9cbnByb3RvLl9yZXNldExheW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdldFNpemUoKTtcbn07XG5cblxucHJvdG8uZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogZ2V0IG1lYXN1cmVtZW50IGZyb20gb3B0aW9uLCBmb3IgY29sdW1uV2lkdGgsIHJvd0hlaWdodCwgZ3V0dGVyXG4gKiBpZiBvcHRpb24gaXMgU3RyaW5nIC0+IGdldCBlbGVtZW50IGZyb20gc2VsZWN0b3Igc3RyaW5nLCAmIGdldCBzaXplIG9mIGVsZW1lbnRcbiAqIGlmIG9wdGlvbiBpcyBFbGVtZW50IC0+IGdldCBzaXplIG9mIGVsZW1lbnRcbiAqIGVsc2UgdXNlIG9wdGlvbiBhcyBhIG51bWJlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZWFzdXJlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSB3aWR0aCBvciBoZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9nZXRNZWFzdXJlbWVudCA9IGZ1bmN0aW9uKCBtZWFzdXJlbWVudCwgc2l6ZSApIHtcbiAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uc1sgbWVhc3VyZW1lbnQgXTtcbiAgdmFyIGVsZW07XG4gIGlmICggIW9wdGlvbiApIHtcbiAgICAvLyBkZWZhdWx0IHRvIDBcbiAgICB0aGlzWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2Ugb3B0aW9uIGFzIGFuIGVsZW1lbnRcbiAgICBpZiAoIHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgKSB7XG4gICAgICBlbGVtID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoIG9wdGlvbiApO1xuICAgIH0gZWxzZSBpZiAoIG9wdGlvbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICkge1xuICAgICAgZWxlbSA9IG9wdGlvbjtcbiAgICB9XG4gICAgLy8gdXNlIHNpemUgb2YgZWxlbWVudCwgaWYgZWxlbWVudFxuICAgIHRoaXNbIG1lYXN1cmVtZW50IF0gPSBlbGVtID8gZ2V0U2l6ZSggZWxlbSApWyBzaXplIF0gOiBvcHRpb247XG4gIH1cbn07XG5cbi8qKlxuICogbGF5b3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtIGVsZW1lbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5wcm90by5sYXlvdXRJdGVtcyA9IGZ1bmN0aW9uKCBpdGVtcywgaXNJbnN0YW50ICkge1xuICBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zRm9yTGF5b3V0KCBpdGVtcyApO1xuXG4gIHRoaXMuX2xheW91dEl0ZW1zKCBpdGVtcywgaXNJbnN0YW50ICk7XG5cbiAgdGhpcy5fcG9zdExheW91dCgpO1xufTtcblxuLyoqXG4gKiBnZXQgdGhlIGl0ZW1zIHRvIGJlIGxhaWQgb3V0XG4gKiB5b3UgbWF5IHdhbnQgdG8gc2tpcCBvdmVyIHNvbWUgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zXG4gKi9cbnByb3RvLl9nZXRJdGVtc0ZvckxheW91dCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlciggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgcmV0dXJuICFpdGVtLmlzSWdub3JlZDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGxheW91dCBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnN0YW50XG4gKi9cbnByb3RvLl9sYXlvdXRJdGVtcyA9IGZ1bmN0aW9uKCBpdGVtcywgaXNJbnN0YW50ICkge1xuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAnbGF5b3V0JywgaXRlbXMgKTtcblxuICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgIC8vIG5vIGl0ZW1zLCBlbWl0IGV2ZW50IHdpdGggZW1wdHkgYXJyYXlcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcXVldWUgPSBbXTtcblxuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAvLyBnZXQgeC95IG9iamVjdCBmcm9tIG1ldGhvZFxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiggaXRlbSApO1xuICAgIC8vIGVucXVldWVcbiAgICBwb3NpdGlvbi5pdGVtID0gaXRlbTtcbiAgICBwb3NpdGlvbi5pc0luc3RhbnQgPSBpc0luc3RhbnQgfHwgaXRlbS5pc0xheW91dEluc3RhbnQ7XG4gICAgcXVldWUucHVzaCggcG9zaXRpb24gKTtcbiAgfSwgdGhpcyApO1xuXG4gIHRoaXMuX3Byb2Nlc3NMYXlvdXRRdWV1ZSggcXVldWUgKTtcbn07XG5cbi8qKlxuICogZ2V0IGl0ZW0gbGF5b3V0IHBvc2l0aW9uXG4gKiBAcGFyYW0ge091dGxheWVyLkl0ZW19IGl0ZW1cbiAqIEByZXR1cm5zIHtPYmplY3R9IHggYW5kIHkgcG9zaXRpb25cbiAqL1xucHJvdG8uX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCAvKiBpdGVtICovICkge1xuICByZXR1cm4ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xufTtcblxuLyoqXG4gKiBpdGVyYXRlIG92ZXIgYXJyYXkgYW5kIHBvc2l0aW9uIGVhY2ggaXRlbVxuICogUmVhc29uIGJlaW5nIC0gc2VwYXJhdGluZyB0aGlzIGxvZ2ljIHByZXZlbnRzICdsYXlvdXQgaW52YWxpZGF0aW9uJ1xuICogdGh4IEBwYXVsX2lyaXNoXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICovXG5wcm90by5fcHJvY2Vzc0xheW91dFF1ZXVlID0gZnVuY3Rpb24oIHF1ZXVlICkge1xuICB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgcXVldWUuZm9yRWFjaCggZnVuY3Rpb24oIG9iaiwgaSApIHtcbiAgICB0aGlzLl9wb3NpdGlvbkl0ZW0oIG9iai5pdGVtLCBvYmoueCwgb2JqLnksIG9iai5pc0luc3RhbnQsIGkgKTtcbiAgfSwgdGhpcyApO1xufTtcblxuLy8gc2V0IHN0YWdnZXIgZnJvbSBvcHRpb24gaW4gbWlsbGlzZWNvbmRzIG51bWJlclxucHJvdG8udXBkYXRlU3RhZ2dlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhZ2dlciA9IHRoaXMub3B0aW9ucy5zdGFnZ2VyO1xuICBpZiAoIHN0YWdnZXIgPT09IG51bGwgfHwgc3RhZ2dlciA9PT0gdW5kZWZpbmVkICkge1xuICAgIHRoaXMuc3RhZ2dlciA9IDA7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuc3RhZ2dlciA9IGdldE1pbGxpc2Vjb25kcyggc3RhZ2dlciApO1xuICByZXR1cm4gdGhpcy5zdGFnZ2VyO1xufTtcblxuLyoqXG4gKiBTZXRzIHBvc2l0aW9uIG9mIGl0ZW0gaW4gRE9NXG4gKiBAcGFyYW0ge091dGxheWVyLkl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gaG9yaXpvbnRhbCBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB2ZXJ0aWNhbCBwb3NpdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBpc0luc3RhbnQgLSBkaXNhYmxlcyB0cmFuc2l0aW9uc1xuICovXG5wcm90by5fcG9zaXRpb25JdGVtID0gZnVuY3Rpb24oIGl0ZW0sIHgsIHksIGlzSW5zdGFudCwgaSApIHtcbiAgaWYgKCBpc0luc3RhbnQgKSB7XG4gICAgLy8gaWYgbm90IHRyYW5zaXRpb24sIGp1c3Qgc2V0IENTU1xuICAgIGl0ZW0uZ29UbyggeCwgeSApO1xuICB9IGVsc2Uge1xuICAgIGl0ZW0uc3RhZ2dlciggaSAqIHRoaXMuc3RhZ2dlciApO1xuICAgIGl0ZW0ubW92ZVRvKCB4LCB5ICk7XG4gIH1cbn07XG5cbi8qKlxuICogQW55IGxvZ2ljIHlvdSB3YW50IHRvIGRvIGFmdGVyIGVhY2ggbGF5b3V0LFxuICogaS5lLiBzaXplIHRoZSBjb250YWluZXJcbiAqL1xucHJvdG8uX3Bvc3RMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZXNpemVDb250YWluZXIoKTtcbn07XG5cbnByb3RvLnJlc2l6ZUNvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXNSZXNpemluZ0NvbnRhaW5lciA9IHRoaXMuX2dldE9wdGlvbigncmVzaXplQ29udGFpbmVyJyk7XG4gIGlmICggIWlzUmVzaXppbmdDb250YWluZXIgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzaXplID0gdGhpcy5fZ2V0Q29udGFpbmVyU2l6ZSgpO1xuICBpZiAoIHNpemUgKSB7XG4gICAgdGhpcy5fc2V0Q29udGFpbmVyTWVhc3VyZSggc2l6ZS53aWR0aCwgdHJ1ZSApO1xuICAgIHRoaXMuX3NldENvbnRhaW5lck1lYXN1cmUoIHNpemUuaGVpZ2h0LCBmYWxzZSApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgd2lkdGggb3IgaGVpZ2h0IG9mIGNvbnRhaW5lciBpZiByZXR1cm5lZFxuICogQHJldHVybnMge09iamVjdH0gc2l6ZVxuICogICBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqICAgQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICovXG5wcm90by5fZ2V0Q29udGFpbmVyU2l6ZSA9IG5vb3A7XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1lYXN1cmUgLSBzaXplIG9mIHdpZHRoIG9yIGhlaWdodFxuICogQHBhcmFtIHtCb29sZWFufSBpc1dpZHRoXG4gKi9cbnByb3RvLl9zZXRDb250YWluZXJNZWFzdXJlID0gZnVuY3Rpb24oIG1lYXN1cmUsIGlzV2lkdGggKSB7XG4gIGlmICggbWVhc3VyZSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVtU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB3aWR0aCBpZiBib3JkZXIgYm94XG4gIGlmICggZWxlbVNpemUuaXNCb3JkZXJCb3ggKSB7XG4gICAgbWVhc3VyZSArPSBpc1dpZHRoID8gZWxlbVNpemUucGFkZGluZ0xlZnQgKyBlbGVtU2l6ZS5wYWRkaW5nUmlnaHQgK1xuICAgICAgZWxlbVNpemUuYm9yZGVyTGVmdFdpZHRoICsgZWxlbVNpemUuYm9yZGVyUmlnaHRXaWR0aCA6XG4gICAgICBlbGVtU2l6ZS5wYWRkaW5nQm90dG9tICsgZWxlbVNpemUucGFkZGluZ1RvcCArXG4gICAgICBlbGVtU2l6ZS5ib3JkZXJUb3BXaWR0aCArIGVsZW1TaXplLmJvcmRlckJvdHRvbVdpZHRoO1xuICB9XG5cbiAgbWVhc3VyZSA9IE1hdGgubWF4KCBtZWFzdXJlLCAwICk7XG4gIHRoaXMuZWxlbWVudC5zdHlsZVsgaXNXaWR0aCA/ICd3aWR0aCcgOiAnaGVpZ2h0JyBdID0gbWVhc3VyZSArICdweCc7XG59O1xuXG4vKipcbiAqIGVtaXQgZXZlbnRDb21wbGV0ZSBvbiBhIGNvbGxlY3Rpb24gb2YgaXRlbXMgZXZlbnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIE91dGxheWVyLkl0ZW1zXG4gKi9cbnByb3RvLl9lbWl0Q29tcGxldGVPbkl0ZW1zID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgaXRlbXMgKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgX3RoaXMuZGlzcGF0Y2hFdmVudCggZXZlbnROYW1lICsgJ0NvbXBsZXRlJywgbnVsbCwgWyBpdGVtcyBdICk7XG4gIH1cblxuICB2YXIgY291bnQgPSBpdGVtcy5sZW5ndGg7XG4gIGlmICggIWl0ZW1zIHx8ICFjb3VudCApIHtcbiAgICBvbkNvbXBsZXRlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRvbmVDb3VudCA9IDA7XG4gIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgZG9uZUNvdW50Kys7XG4gICAgaWYgKCBkb25lQ291bnQgPT0gY291bnQgKSB7XG4gICAgICBvbkNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYmluZCBjYWxsYmFja1xuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLm9uY2UoIGV2ZW50TmFtZSwgdGljayApO1xuICB9KTtcbn07XG5cbi8qKlxuICogZW1pdHMgZXZlbnRzIHZpYSBFdkVtaXR0ZXIgYW5kIGpRdWVyeSBldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gbmFtZSBvZiBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBvcmlnaW5hbCBldmVudFxuICogQHBhcmFtIHtBcnJheX0gYXJncyAtIGV4dHJhIGFyZ3VtZW50c1xuICovXG5wcm90by5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xuICAvLyBhZGQgb3JpZ2luYWwgZXZlbnQgdG8gYXJndW1lbnRzXG4gIHZhciBlbWl0QXJncyA9IGV2ZW50ID8gWyBldmVudCBdLmNvbmNhdCggYXJncyApIDogYXJncztcbiAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XG5cbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgLy8gc2V0IHRoaXMuJGVsZW1lbnRcbiAgICB0aGlzLiRlbGVtZW50ID0gdGhpcy4kZWxlbWVudCB8fCBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICAgIGlmICggZXZlbnQgKSB7XG4gICAgICAvLyBjcmVhdGUgalF1ZXJ5IGV2ZW50XG4gICAgICB2YXIgJGV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xuICAgICAgJGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCAkZXZlbnQsIGFyZ3MgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCB0cmlnZ2VyIHdpdGggdHlwZSBpZiBubyBldmVudCBhdmFpbGFibGVcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggdHlwZSwgYXJncyApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaWdub3JlICYgc3RhbXBzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cblxuLyoqXG4gKiBrZWVwIGl0ZW0gaW4gY29sbGVjdGlvbiwgYnV0IGRvIG5vdCBsYXkgaXQgb3V0XG4gKiBpZ25vcmVkIGl0ZW1zIGRvIG5vdCBnZXQgc2tpcHBlZCBpbiBsYXlvdXRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICovXG5wcm90by5pZ25vcmUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgaWYgKCBpdGVtICkge1xuICAgIGl0ZW0uaXNJZ25vcmVkID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiByZXR1cm4gaXRlbSB0byBsYXlvdXQgY29sbGVjdGlvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKi9cbnByb3RvLnVuaWdub3JlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gIGlmICggaXRlbSApIHtcbiAgICBkZWxldGUgaXRlbS5pc0lnbm9yZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogYWRkcyBlbGVtZW50cyB0byBzdGFtcHNcbiAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBFbGVtZW50LCBvciBTdHJpbmd9IGVsZW1zXG4gKi9cbnByb3RvLnN0YW1wID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBlbGVtcyA9IHRoaXMuX2ZpbmQoIGVsZW1zICk7XG4gIGlmICggIWVsZW1zICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc3RhbXBzID0gdGhpcy5zdGFtcHMuY29uY2F0KCBlbGVtcyApO1xuICAvLyBpZ25vcmVcbiAgZWxlbXMuZm9yRWFjaCggdGhpcy5pZ25vcmUsIHRoaXMgKTtcbn07XG5cbi8qKlxuICogcmVtb3ZlcyBlbGVtZW50cyB0byBzdGFtcHNcbiAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by51bnN0YW1wID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBlbGVtcyA9IHRoaXMuX2ZpbmQoIGVsZW1zICk7XG4gIGlmICggIWVsZW1zICl7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgLy8gZmlsdGVyIG91dCByZW1vdmVkIHN0YW1wIGVsZW1lbnRzXG4gICAgdXRpbHMucmVtb3ZlRnJvbSggdGhpcy5zdGFtcHMsIGVsZW0gKTtcbiAgICB0aGlzLnVuaWdub3JlKCBlbGVtICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cbi8qKlxuICogZmluZHMgY2hpbGQgZWxlbWVudHNcbiAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBFbGVtZW50LCBvciBTdHJpbmd9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGVsZW1zXG4gKi9cbnByb3RvLl9maW5kID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBpZiAoICFlbGVtcyApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gaWYgc3RyaW5nLCB1c2UgYXJndW1lbnQgYXMgc2VsZWN0b3Igc3RyaW5nXG4gIGlmICggdHlwZW9mIGVsZW1zID09ICdzdHJpbmcnICkge1xuICAgIGVsZW1zID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIGVsZW1zICk7XG4gIH1cbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHJldHVybiBlbGVtcztcbn07XG5cbnByb3RvLl9tYW5hZ2VTdGFtcHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5zdGFtcHMgfHwgIXRoaXMuc3RhbXBzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9nZXRCb3VuZGluZ1JlY3QoKTtcblxuICB0aGlzLnN0YW1wcy5mb3JFYWNoKCB0aGlzLl9tYW5hZ2VTdGFtcCwgdGhpcyApO1xufTtcblxuLy8gdXBkYXRlIGJvdW5kaW5nTGVmdCAvIFRvcFxucHJvdG8uX2dldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBnZXQgYm91bmRpbmcgcmVjdCBmb3IgY29udGFpbmVyIGVsZW1lbnRcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gIHRoaXMuX2JvdW5kaW5nUmVjdCA9IHtcbiAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCArIHNpemUucGFkZGluZ0xlZnQgKyBzaXplLmJvcmRlckxlZnRXaWR0aCxcbiAgICB0b3A6IGJvdW5kaW5nUmVjdC50b3AgKyBzaXplLnBhZGRpbmdUb3AgKyBzaXplLmJvcmRlclRvcFdpZHRoLFxuICAgIHJpZ2h0OiBib3VuZGluZ1JlY3QucmlnaHQgLSAoIHNpemUucGFkZGluZ1JpZ2h0ICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoICksXG4gICAgYm90dG9tOiBib3VuZGluZ1JlY3QuYm90dG9tIC0gKCBzaXplLnBhZGRpbmdCb3R0b20gKyBzaXplLmJvcmRlckJvdHRvbVdpZHRoIClcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBzdGFtcFxuKiovXG5wcm90by5fbWFuYWdlU3RhbXAgPSBub29wO1xuXG4vKipcbiAqIGdldCB4L3kgcG9zaXRpb24gb2YgZWxlbWVudCByZWxhdGl2ZSB0byBjb250YWluZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvZmZzZXQgLSBoYXMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gKi9cbnByb3RvLl9nZXRFbGVtZW50T2Zmc2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBib3VuZGluZ1JlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdGhpc1JlY3QgPSB0aGlzLl9ib3VuZGluZ1JlY3Q7XG4gIHZhciBzaXplID0gZ2V0U2l6ZSggZWxlbSApO1xuICB2YXIgb2Zmc2V0ID0ge1xuICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0IC0gdGhpc1JlY3QubGVmdCAtIHNpemUubWFyZ2luTGVmdCxcbiAgICB0b3A6IGJvdW5kaW5nUmVjdC50b3AgLSB0aGlzUmVjdC50b3AgLSBzaXplLm1hcmdpblRvcCxcbiAgICByaWdodDogdGhpc1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QucmlnaHQgLSBzaXplLm1hcmdpblJpZ2h0LFxuICAgIGJvdHRvbTogdGhpc1JlY3QuYm90dG9tIC0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIHNpemUubWFyZ2luQm90dG9tXG4gIH07XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSByZXNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZW5hYmxlIGV2ZW50IGhhbmRsZXJzIGZvciBsaXN0ZW5lcnNcbi8vIGkuZS4gcmVzaXplIC0+IG9ucmVzaXplXG5wcm90by5oYW5kbGVFdmVudCA9IHV0aWxzLmhhbmRsZUV2ZW50O1xuXG4vKipcbiAqIEJpbmQgbGF5b3V0IHRvIHdpbmRvdyByZXNpemluZ1xuICovXG5wcm90by5iaW5kUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcyApO1xuICB0aGlzLmlzUmVzaXplQm91bmQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgbGF5b3V0IHRvIHdpbmRvdyByZXNpemluZ1xuICovXG5wcm90by51bmJpbmRSZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIHRoaXMuaXNSZXNpemVCb3VuZCA9IGZhbHNlO1xufTtcblxucHJvdG8ub25yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZXNpemUoKTtcbn07XG5cbnV0aWxzLmRlYm91bmNlTWV0aG9kKCBPdXRsYXllciwgJ29ucmVzaXplJywgMTAwICk7XG5cbnByb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkb24ndCB0cmlnZ2VyIGlmIHNpemUgZGlkIG5vdCBjaGFuZ2VcbiAgLy8gb3IgaWYgcmVzaXplIHdhcyB1bmJvdW5kLiBTZWUgIzlcbiAgaWYgKCAhdGhpcy5pc1Jlc2l6ZUJvdW5kIHx8ICF0aGlzLm5lZWRzUmVzaXplTGF5b3V0KCkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5sYXlvdXQoKTtcbn07XG5cbi8qKlxuICogY2hlY2sgaWYgbGF5b3V0IGlzIG5lZWRlZCBwb3N0IGxheW91dFxuICogQHJldHVybnMgQm9vbGVhblxuICovXG5wcm90by5uZWVkc1Jlc2l6ZUxheW91dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xuICAvLyBjaGVjayB0aGF0IHRoaXMuc2l6ZSBhbmQgc2l6ZSBhcmUgdGhlcmVcbiAgLy8gSUU4IHRyaWdnZXJzIHJlc2l6ZSBvbiBib2R5IHNpemUgY2hhbmdlLCBzbyB0aGV5IG1pZ2h0IG5vdCBiZVxuICB2YXIgaGFzU2l6ZXMgPSB0aGlzLnNpemUgJiYgc2l6ZTtcbiAgcmV0dXJuIGhhc1NpemVzICYmIHNpemUuaW5uZXJXaWR0aCAhPT0gdGhpcy5zaXplLmlubmVyV2lkdGg7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogYWRkIGl0ZW1zIHRvIE91dGxheWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gT3V0bGF5ZXIuSXRlbXNcbioqL1xucHJvdG8uYWRkSXRlbXMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1pemUoIGVsZW1zICk7XG4gIC8vIGFkZCBpdGVtcyB0byBjb2xsZWN0aW9uXG4gIGlmICggaXRlbXMubGVuZ3RoICkge1xuICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmNvbmNhdCggaXRlbXMgKTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIExheW91dCBuZXdseS1hcHBlbmRlZCBpdGVtIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLmFwcGVuZGVkID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLmFkZEl0ZW1zKCBlbGVtcyApO1xuICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGxheW91dCBhbmQgcmV2ZWFsIGp1c3QgdGhlIG5ldyBpdGVtc1xuICB0aGlzLmxheW91dEl0ZW1zKCBpdGVtcywgdHJ1ZSApO1xuICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogTGF5b3V0IHByZXBlbmRlZCBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by5wcmVwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1pemUoIGVsZW1zICk7XG4gIGlmICggIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYWRkIGl0ZW1zIHRvIGJlZ2lubmluZyBvZiBjb2xsZWN0aW9uXG4gIHZhciBwcmV2aW91c0l0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwKTtcbiAgdGhpcy5pdGVtcyA9IGl0ZW1zLmNvbmNhdCggcHJldmlvdXNJdGVtcyApO1xuICAvLyBzdGFydCBuZXcgbGF5b3V0XG4gIHRoaXMuX3Jlc2V0TGF5b3V0KCk7XG4gIHRoaXMuX21hbmFnZVN0YW1wcygpO1xuICAvLyBsYXlvdXQgbmV3IHN0dWZmIHdpdGhvdXQgdHJhbnNpdGlvblxuICB0aGlzLmxheW91dEl0ZW1zKCBpdGVtcywgdHJ1ZSApO1xuICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbiAgLy8gbGF5b3V0IHByZXZpb3VzIGl0ZW1zXG4gIHRoaXMubGF5b3V0SXRlbXMoIHByZXZpb3VzSXRlbXMgKTtcbn07XG5cbi8qKlxuICogcmV2ZWFsIGEgY29sbGVjdGlvbiBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheSBvZiBPdXRsYXllci5JdGVtc30gaXRlbXNcbiAqL1xucHJvdG8ucmV2ZWFsID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAncmV2ZWFsJywgaXRlbXMgKTtcbiAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHN0YWdnZXIgPSB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG4gICAgaXRlbS5zdGFnZ2VyKCBpICogc3RhZ2dlciApO1xuICAgIGl0ZW0ucmV2ZWFsKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBoaWRlIGEgY29sbGVjdGlvbiBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheSBvZiBPdXRsYXllci5JdGVtc30gaXRlbXNcbiAqL1xucHJvdG8uaGlkZSA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ2hpZGUnLCBpdGVtcyApO1xuICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RhZ2dlciA9IHRoaXMudXBkYXRlU3RhZ2dlcigpO1xuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcbiAgICBpdGVtLnN0YWdnZXIoIGkgKiBzdGFnZ2VyICk7XG4gICAgaXRlbS5oaWRlKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiByZXZlYWwgaXRlbSBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheX0sIHtFbGVtZW50fSwge05vZGVMaXN0fSBpdGVtc1xuICovXG5wcm90by5yZXZlYWxJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoIGVsZW1zICk7XG4gIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBoaWRlIGl0ZW0gZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9LCB7RWxlbWVudH0sIHtOb2RlTGlzdH0gaXRlbXNcbiAqL1xucHJvdG8uaGlkZUl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcbiAgdGhpcy5oaWRlKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBnZXQgT3V0bGF5ZXIuSXRlbSwgZ2l2ZW4gYW4gRWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge091dGxheWVyLkl0ZW19IGl0ZW1cbiAqL1xucHJvdG8uZ2V0SXRlbSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAvLyBsb29wIHRocm91Z2ggaXRlbXMgdG8gZ2V0IHRoZSBvbmUgdGhhdCBtYXRjaGVzXG4gIGZvciAoIHZhciBpPTA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICBpZiAoIGl0ZW0uZWxlbWVudCA9PSBlbGVtICkge1xuICAgICAgLy8gcmV0dXJuIGl0ZW1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgY29sbGVjdGlvbiBvZiBPdXRsYXllci5JdGVtcywgZ2l2ZW4gRWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gT3V0bGF5ZXIuSXRlbXNcbiAqL1xucHJvdG8uZ2V0SXRlbXMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBlbGVtcyApO1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgICBpZiAoIGl0ZW0gKSB7XG4gICAgICBpdGVtcy5wdXNoKCBpdGVtICk7XG4gICAgfVxuICB9LCB0aGlzICk7XG5cbiAgcmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiByZW1vdmUgZWxlbWVudChzKSBmcm9tIGluc3RhbmNlIGFuZCBET01cbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgcmVtb3ZlSXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuXG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdyZW1vdmUnLCByZW1vdmVJdGVtcyApO1xuXG4gIC8vIGJhaWwgaWYgbm8gaXRlbXMgdG8gcmVtb3ZlXG4gIGlmICggIXJlbW92ZUl0ZW1zIHx8ICFyZW1vdmVJdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVtb3ZlSXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5yZW1vdmUoKTtcbiAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGNvbGxlY3Rpb25cbiAgICB1dGlscy5yZW1vdmVGcm9tKCB0aGlzLml0ZW1zLCBpdGVtICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cbi8vIC0tLS0tIGRlc3Ryb3kgLS0tLS0gLy9cblxuLy8gcmVtb3ZlIGFuZCBkaXNhYmxlIE91dGxheWVyIGluc3RhbmNlXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNsZWFuIHVwIGR5bmFtaWMgc3R5bGVzXG4gIHZhciBzdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcbiAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gIHN0eWxlLnBvc2l0aW9uID0gJyc7XG4gIHN0eWxlLndpZHRoID0gJyc7XG4gIC8vIGRlc3Ryb3kgaXRlbXNcbiAgdGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLmRlc3Ryb3koKTtcbiAgfSk7XG5cbiAgdGhpcy51bmJpbmRSZXNpemUoKTtcblxuICB2YXIgaWQgPSB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEO1xuICBkZWxldGUgaW5zdGFuY2VzWyBpZCBdOyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIGluc3RhbmNlIGJ5IGlkXG4gIGRlbGV0ZSB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEO1xuICAvLyByZW1vdmUgZGF0YSBmb3IgalF1ZXJ5XG4gIGlmICggalF1ZXJ5ICkge1xuICAgIGpRdWVyeS5yZW1vdmVEYXRhKCB0aGlzLmVsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IubmFtZXNwYWNlICk7XG4gIH1cblxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGF0YSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGdldCBPdXRsYXllciBpbnN0YW5jZSBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge091dGxheWVyfVxuICovXG5PdXRsYXllci5kYXRhID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIGVsZW0gPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW0gKTtcbiAgdmFyIGlkID0gZWxlbSAmJiBlbGVtLm91dGxheWVyR1VJRDtcbiAgcmV0dXJuIGlkICYmIGluc3RhbmNlc1sgaWQgXTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gY3JlYXRlIE91dGxheWVyIGNsYXNzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogY3JlYXRlIGEgbGF5b3V0IGNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKi9cbk91dGxheWVyLmNyZWF0ZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2UsIG9wdGlvbnMgKSB7XG4gIC8vIHN1Yi1jbGFzcyBPdXRsYXllclxuICB2YXIgTGF5b3V0ID0gc3ViY2xhc3MoIE91dGxheWVyICk7XG4gIC8vIGFwcGx5IG5ldyBvcHRpb25zIGFuZCBjb21wYXRPcHRpb25zXG4gIExheW91dC5kZWZhdWx0cyA9IHV0aWxzLmV4dGVuZCgge30sIE91dGxheWVyLmRlZmF1bHRzICk7XG4gIHV0aWxzLmV4dGVuZCggTGF5b3V0LmRlZmF1bHRzLCBvcHRpb25zICk7XG4gIExheW91dC5jb21wYXRPcHRpb25zID0gdXRpbHMuZXh0ZW5kKCB7fSwgT3V0bGF5ZXIuY29tcGF0T3B0aW9ucyAgKTtcblxuICBMYXlvdXQubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIExheW91dC5kYXRhID0gT3V0bGF5ZXIuZGF0YTtcblxuICAvLyBzdWItY2xhc3MgSXRlbVxuICBMYXlvdXQuSXRlbSA9IHN1YmNsYXNzKCBJdGVtICk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGVjbGFyYXRpdmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICB1dGlscy5odG1sSW5pdCggTGF5b3V0LCBuYW1lc3BhY2UgKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBqUXVlcnkgYnJpZGdlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgLy8gbWFrZSBpbnRvIGpRdWVyeSBwbHVnaW5cbiAgaWYgKCBqUXVlcnkgJiYgalF1ZXJ5LmJyaWRnZXQgKSB7XG4gICAgalF1ZXJ5LmJyaWRnZXQoIG5hbWVzcGFjZSwgTGF5b3V0ICk7XG4gIH1cblxuICByZXR1cm4gTGF5b3V0O1xufTtcblxuZnVuY3Rpb24gc3ViY2xhc3MoIFBhcmVudCApIHtcbiAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XG4gICAgUGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIFN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcbiAgU3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViQ2xhc3M7XG5cbiAgcmV0dXJuIFN1YkNsYXNzO1xufVxuXG4vLyAtLS0tLSBoZWxwZXJzIC0tLS0tIC8vXG5cbi8vIGhvdyBtYW55IG1pbGxpc2Vjb25kcyBhcmUgaW4gZWFjaCB1bml0XG52YXIgbXNVbml0cyA9IHtcbiAgbXM6IDEsXG4gIHM6IDEwMDBcbn07XG5cbi8vIG11bmdlIHRpbWUtbGlrZSBwYXJhbWV0ZXIgaW50byBtaWxsaXNlY29uZCBudW1iZXJcbi8vICcwLjRzJyAtPiA0MFxuZnVuY3Rpb24gZ2V0TWlsbGlzZWNvbmRzKCB0aW1lICkge1xuICBpZiAoIHR5cGVvZiB0aW1lID09ICdudW1iZXInICkge1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIHZhciBtYXRjaGVzID0gdGltZS5tYXRjaCggLyheXFxkKlxcLj9cXGQqKShcXHcqKS8gKTtcbiAgdmFyIG51bSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXTtcbiAgdmFyIHVuaXQgPSBtYXRjaGVzICYmIG1hdGNoZXNbMl07XG4gIGlmICggIW51bS5sZW5ndGggKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbnVtID0gcGFyc2VGbG9hdCggbnVtICk7XG4gIHZhciBtdWx0ID0gbXNVbml0c1sgdW5pdCBdIHx8IDE7XG4gIHJldHVybiBudW0gKiBtdWx0O1xufVxuXG4vLyAtLS0tLSBmaW4gLS0tLS0gLy9cblxuLy8gYmFjayBpbiBnbG9iYWxcbk91dGxheWVyLkl0ZW0gPSBJdGVtO1xuXG5yZXR1cm4gT3V0bGF5ZXI7XG5cbn0pKTtcbiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwiRXZFbWl0dGVyIiwiZ2V0U2l6ZSIsInV0aWxzIiwiSXRlbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiT3V0bGF5ZXIiLCJmaXp6eVVJVXRpbHMiLCJjb25zb2xlIiwialF1ZXJ5Iiwibm9vcCIsIkdVSUQiLCJpbnN0YW5jZXMiLCJlbGVtZW50Iiwib3B0aW9ucyIsInF1ZXJ5RWxlbWVudCIsImdldFF1ZXJ5RWxlbWVudCIsImVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lc3BhY2UiLCIkZWxlbWVudCIsImV4dGVuZCIsImRlZmF1bHRzIiwib3B0aW9uIiwiaWQiLCJvdXRsYXllckdVSUQiLCJfY3JlYXRlIiwiaXNJbml0TGF5b3V0IiwiX2dldE9wdGlvbiIsImxheW91dCIsImNvbnRhaW5lclN0eWxlIiwicG9zaXRpb24iLCJpbml0TGF5b3V0Iiwib3JpZ2luTGVmdCIsIm9yaWdpblRvcCIsInJlc2l6ZSIsInJlc2l6ZUNvbnRhaW5lciIsInRyYW5zaXRpb25EdXJhdGlvbiIsImhpZGRlblN0eWxlIiwib3BhY2l0eSIsInRyYW5zZm9ybSIsInZpc2libGVTdHlsZSIsInByb3RvIiwicHJvdG90eXBlIiwib3B0cyIsIm9sZE9wdGlvbiIsImNvbXBhdE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJob3Jpem9udGFsIiwibGF5b3V0SW5zdGFudCIsInJlbG9hZEl0ZW1zIiwic3RhbXBzIiwic3RhbXAiLCJzdHlsZSIsImNhbkJpbmRSZXNpemUiLCJiaW5kUmVzaXplIiwiaXRlbXMiLCJfaXRlbWl6ZSIsImNoaWxkcmVuIiwiZWxlbXMiLCJpdGVtRWxlbXMiLCJfZmlsdGVyRmluZEl0ZW1FbGVtZW50cyIsImkiLCJsZW5ndGgiLCJlbGVtIiwiaXRlbSIsInB1c2giLCJmaWx0ZXJGaW5kRWxlbWVudHMiLCJpdGVtU2VsZWN0b3IiLCJnZXRJdGVtRWxlbWVudHMiLCJtYXAiLCJfcmVzZXRMYXlvdXQiLCJfbWFuYWdlU3RhbXBzIiwiaXNJbnN0YW50IiwiX2lzTGF5b3V0SW5pdGVkIiwibGF5b3V0SXRlbXMiLCJfaW5pdCIsInNpemUiLCJfZ2V0TWVhc3VyZW1lbnQiLCJtZWFzdXJlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIl9nZXRJdGVtc0ZvckxheW91dCIsIl9sYXlvdXRJdGVtcyIsIl9wb3N0TGF5b3V0IiwiZmlsdGVyIiwiaXNJZ25vcmVkIiwiX2VtaXRDb21wbGV0ZU9uSXRlbXMiLCJxdWV1ZSIsImZvckVhY2giLCJfZ2V0SXRlbUxheW91dFBvc2l0aW9uIiwiaXNMYXlvdXRJbnN0YW50IiwiX3Byb2Nlc3NMYXlvdXRRdWV1ZSIsIngiLCJ5IiwidXBkYXRlU3RhZ2dlciIsIm9iaiIsIl9wb3NpdGlvbkl0ZW0iLCJzdGFnZ2VyIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ29UbyIsIm1vdmVUbyIsImlzUmVzaXppbmdDb250YWluZXIiLCJfZ2V0Q29udGFpbmVyU2l6ZSIsIl9zZXRDb250YWluZXJNZWFzdXJlIiwid2lkdGgiLCJoZWlnaHQiLCJtZWFzdXJlIiwiaXNXaWR0aCIsImVsZW1TaXplIiwiaXNCb3JkZXJCb3giLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ1RvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJNYXRoIiwibWF4IiwiZXZlbnROYW1lIiwiX3RoaXMiLCJvbkNvbXBsZXRlIiwiZGlzcGF0Y2hFdmVudCIsImNvdW50IiwiZG9uZUNvdW50IiwidGljayIsIm9uY2UiLCJ0eXBlIiwiZXZlbnQiLCJhcmdzIiwiZW1pdEFyZ3MiLCJjb25jYXQiLCJlbWl0RXZlbnQiLCIkZXZlbnQiLCJFdmVudCIsInRyaWdnZXIiLCJpZ25vcmUiLCJnZXRJdGVtIiwidW5pZ25vcmUiLCJfZmluZCIsInVuc3RhbXAiLCJyZW1vdmVGcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsIm1ha2VBcnJheSIsIl9nZXRCb3VuZGluZ1JlY3QiLCJfbWFuYWdlU3RhbXAiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfYm91bmRpbmdSZWN0IiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiX2dldEVsZW1lbnRPZmZzZXQiLCJ0aGlzUmVjdCIsIm9mZnNldCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsImhhbmRsZUV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImlzUmVzaXplQm91bmQiLCJ1bmJpbmRSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25yZXNpemUiLCJkZWJvdW5jZU1ldGhvZCIsIm5lZWRzUmVzaXplTGF5b3V0IiwiaGFzU2l6ZXMiLCJpbm5lcldpZHRoIiwiYWRkSXRlbXMiLCJhcHBlbmRlZCIsInJldmVhbCIsInByZXBlbmRlZCIsInByZXZpb3VzSXRlbXMiLCJzbGljZSIsImhpZGUiLCJyZXZlYWxJdGVtRWxlbWVudHMiLCJnZXRJdGVtcyIsImhpZGVJdGVtRWxlbWVudHMiLCJyZW1vdmUiLCJyZW1vdmVJdGVtcyIsImRlc3Ryb3kiLCJyZW1vdmVEYXRhIiwiZGF0YSIsImNyZWF0ZSIsIkxheW91dCIsInN1YmNsYXNzIiwiaHRtbEluaXQiLCJicmlkZ2V0IiwiUGFyZW50IiwiU3ViQ2xhc3MiLCJhcHBseSIsImFyZ3VtZW50cyIsIk9iamVjdCIsIm1zVW5pdHMiLCJtcyIsInMiLCJ0aW1lIiwibWF0Y2hlcyIsIm1hdGNoIiwibnVtIiwidW5pdCIsInBhcnNlRmxvYXQiLCJtdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/outlayer.js\n");

/***/ })

};
;